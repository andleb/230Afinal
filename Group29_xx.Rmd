---
title: |
  | STAT 230A Final Project
  | Replication of Michalopoulos: The Origins of Ethnolinguistic Diversity
author: 
  - Andrej Leban, andrej_leban@berkeley.edu
  - Isaac Schmidt, ischmidt20@berkeley.edu
email: 
  - "andrej_leban@berkeley.edu"
  - "ischmidt20@berkeley.edu"
nocite: | 
  @ding_linear_2022
# date: "`r format(Sys.time(), '%B %d, %Y')`"
header-includes:
  - \usepackage{float, amsthm, amsmath, amssymb, bm, enumitem, latexsym, color, minipage-marginpar, caption, multirow, verbatim, xcolor, setspace, fancyhdr}
geometry: margin=1in
# linestretch: 1.5
output:
  pdf_document:
    # TODO: enable for the final writeup
    toc: no
    number_sections: true
    df_print: kable
papersize: a4
urlcolor: blue
bibliography: [references.bib]
editor_options:
  markdown:
    wrap: 120
always_allow_html: true
---

```{r setup, echo = FALSE, message=FALSE, warning=FALSE}
library(conflicted)
library(MASS)
library(sandwich)
library(lmtest)
library(estimatr)

# extra:
library(gsubfn)
library(reshape2)

library(data.table)

library(knitr)
library(kableExtra)
library(ggrastr)

library(readstata13)
library(sf)

library(viridis)
library(tidyverse)

# NOTE: this is to make only the displayed code smaller
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr") 

# set default knitr chunks
knitr::opts_chunk$set(
  echo = TRUE,
  fig.align = "center",
  fig.height = 4,
  fig.pos = "H",
  fig.width = 6,
  message = FALSE,
  warning = FALSE,
  cache = F,
  results = 'hide', 
  size="small"
)

options(knitr.kable.NA = '')

# define my_theme - append here
my_theme <- theme_minimal()
```

`r #TODO: margins, font size, group name & name in upper right`

<!-- LaTeX preamble -->
  \newcommand{\E}{{\mathbb E}}
\newcommand{\se}{{\mathcal{E}}}
\newcommand{\R}{{\mathbb R}}
\renewcommand{\P}{{\mathbb P}}
\newcommand{\ac}{{\mathcal{A}}}
\newcommand{\A}{{\mathcal{A}}}
\newcommand{\B}{{\mathcal{B}}}
\newcommand{\T}{{\mathcal{T}}}
\newcommand{\Z}{{\mathcal{Z}}}
\newcommand{\K}{{\mathcal{K}}}
\newcommand{\lc}{{\mathcal{L}}}
\newcommand{\Ps}{{\mathcal{P}}}
\newcommand{\pa}{{\mathring{p}}}
\newcommand{\F}{{\cal F}}
\newcommand{\samp}{{\mathcal{X}}}
\newcommand{\X}{{\mathcal{X}}}
\newcommand{\hi}{{\hat{\Phi}}}

\def\qt#1{\qquad\text{#1}}

\def\argmin{\mathop{\rm argmin}}
\def\argmax{\mathop{\rm argmax}}

\setlength{\parskip}{1.4 \medskipamount}

\onehalfspacing

\pagestyle{fancy}
\fancypagestyle{plain}{\pagestyle{fancy}}
\fancyhead[R]{Group 29, Isaac Schmidt}



```{r dataImport1, echo=F}
cells = read_sf(dsn = 'data_raw/Virtual_country', layer = 'virtual_cntrygrid')
countries = read_sf(dsn = 'countries', layer = 'countries')
data = read.dta13("data_raw/Tables1-3a.dta")
```

```{r rename1, echo=F}
colnames(data) = c('countryCode', 'entryYear', 'countryName', 'avgTemp', 
                   'avgPrecip', 'seaDist', 'avgElev', 'sdElev', 'absLat', 
                   'dispElev', 'numLang', 'suitableCells', 'dispSuitable',
                   'climate', 'soil', 'sdClimate', 'sdSoil', 'sdSuitable', 
                   'avgSuitable', 'pop95', 'area', 'lnLang', 'africa', 
                   'europe', 'americas', 'lnPopDens1995', 'migrationDist', 
                   'lnArea', 'pctIndigenous', 'lnPopDens1500', 
                   'agriTran', 'asiaPac')
```

# Paper Summary & Summary Statistics Table

## Paper Summary

The paper by Michalopoulos [@michalopoulos_origins_2012] aims to explain ethnolinguistic diversity within and across countries by assuming that a proxy quantity—the number of languages per square kilometer—is determined by a selection of various economic, historical, andgeographic variables. It determines that *variation in regional land quality* and *variation in elevation* are the most significant determinants of linguistic diversity. The hypothesis underpinning this examination is that differences in local land characteristics induce different levels of human capital across locations, which in turn, gives rise to localized ethnicities that are characterized by separate languages. The results of the empirical study presented are found to be consistent with this hypothesis.

The empirical results are obtained separately by three regressions:  

* **Cross-country**: this takes the current political borders as the unit within which covariates such as the number of languages are counted.

* **Virtual countries**: To account for the arbitrary nature of some political boundaries with respect to ethnolinguistic groupings, the world is split into arbitrary *virtual countries* and the regression is performed again.
  
* **Adjacent regions**: To account for a potentially high "baseline" effect in some regions, adjacent regions are compared directly, which neutralizes region-specific fixed effects and focuses on the effect of the variables under consideration.
  
<!-- Finally, in regions that have undergone a major demographic shift in the last 500 years, the explanatory power of the model -->
<!-- is found to be significantly weaker; these regions are controlled for with a dummy variable. -->

## Exploratory Data Analysis and Summary Table

The data comes from multiple sources: the standard geographic data was sourced from the *Geographically Based Economic Data database*, the data on land quality for agriculture comes from *Ramankutty et al. (2002)*, and the data on the distribution of languages comes from the *World Language Mapping System*. Fortunately, the data provided by the author was already processed and cleaned to the extent used in the paper, so all we did was rename columns to more descriptive names.

The paper lacks a true summary table and shows a couple of EDA figures instead. We replicate two of those figures, and then display our own summary table of the features used in the paper's first regression—the *cross-country model*. Figure \ref{fig:suit} shows the distribution of land suitability for agriculture across the world at a resolution of .5-by.5 decimal degrees. The dependent variable represents the probability that a particular grid cell may be cultivated. 

```{r fig1, fig.cap="\\label{fig:suit} Land quality for agriculture across countries", echo=F, cache=T, fig.width = 6, fig.height=4}
fig1 = ggplot(cells) + rasterize(geom_sf(aes(fill = suit_new), colour = NA), dpi=450) +
  scale_fill_viridis_c("Land quality", direction = -1 ) + my_theme
fig1
```

```{r greeceNepal, cache=TRUE, echo=F}
greeceCells = countries %>% filter(COUNTRY == 'Greece') %>%
  st_intersection(y = cells)
nepalCells = countries %>% filter(COUNTRY == 'Nepal') %>%
  st_intersection(y = cells)
```

Figure \ref{fig:kde1} shows the distribution of land quality within two countries selected in the paper—Greece and Nepal, obtained with a kernel density estimate using the Epanechnikov kernel.

```{r worldMap, fig.cap="\\label{fig:kde1} Kernel density of land quality in Greece and Nepal", echo=F, fig.width = 5, fig.height=3}
plot(
  density(greeceCells$suit_new, kernel = "epanechnikov"),
  xlim = c(0, 1),
  xlab = 'Land quality per region',
  ylab = 'Density',
  main = '',
  lty = 2
)
lines(density(nepalCells$suit_new, kernel = "epanechnikov"), col = 'red')
legend(
  .1,
  3,
  legend = c(
    'Distribution of land quality in Greece',
    'Distribution of land quality in Nepal'
  ),
  col = c("black", "red"),
  lty = 2:1,
  cex = .75
)
```

Table \ref{tab:summaryPrint} shows summary statistics of important variables for the first model. The dependent variable is `numLang`, which is the number of languages whose "traditional homeland" intersects with the country's boundary. Additional covariates are measures of centrality and variablity of the geographic data, the log of the country's 1995 population, human migration distance from Africa, and distance from a large body of water. While some other variables in the provided dataset have missing values for some countries, note that all variables included in the first regression are known for all countries.  

```{r summary, results='hide', echo=F}
count = function(x) {
  (sum( ~ is.na(x)))
}

sumTable <- data %>% select(
  c(
    'numLang',
    'sdElev',
    'sdSuitable',
    'avgElev',
    'avgSuitable',
    'absLat',
    'avgPrecip',
    'avgTemp',
    'lnArea',
    'seaDist',
    'migrationDist',
    'lnPopDens1995'
  )
) %>%
  summarise_each(
    funs(
      min = min,
      median = median,
      max = max,
      mean = mean,
      iqr = quantile(., 0.75) - quantile(., 0.25),
      sd = sd,
      n = sum(!is.na(.))
    )
  ) %>%
  gather(var, val) %>%
  separate(var, into = c("var", "stat"), sep = "_") %>%
  spread(var, val) %>% column_to_rownames(var = "stat") %>%
  select(
    c(
      'numLang',
      'sdElev',
      'sdSuitable',
      'avgElev',
      'avgSuitable',
      'absLat',
      'avgPrecip',
      'avgTemp',
      'lnArea',
      'seaDist',
      'migrationDist',
      'lnPopDens1995'
    )
  ) %>%
  mutate_if(is.numeric, ~ round(., 2)) %>% slice(5, 4, 2, 3, 7)
```

```{r summaryPrint, results='show', echo=F}
knitr::kable(sumTable, toprule = '', bottomrule = '', booktabs = TRUE, linesep = c(""), caption = 'Summary statistics for covariates in cross-country analysis') %>% row_spec(0, angle = 90)
```


# Analysis 1: Cross-Country

The first model regresses the (log) number of languages within each country on the features described above. Michalopolous presents five different regression models, each containing a different number of covariates. The model, as described in the original paper, is the following:

\begin{equation} \label{eq:model1}
\ln\left(\text{numLang}_i\right) = \beta_0 + \beta_1*\text{absLat}_i + \beta_2*\text{sdElev}_i + \beta_3*\text{sdSuitable}_i + \beta_4* X_i + \epsilon_i
\end{equation}

The first model only includes absolute latitude, the second model adds the mean and standard deviation of both elevation and land quality within each country, and the remaining models add additional covariates $X_i$.

## Statement of Assumptions

The canonical assumptions of a linear model are that Equation \ref{eq:model1} actually is the data-generation process, and that the error terms $\epsilon_i$ are normal with mean 0, and constant variance $\sigma^2$. Of course, these assumptions are rarely actually true, but fortunately, they can be relaxed slightly.

In the original paper, Michalopolous reported "robust" standard errors for the estimated coefficients, following Eicker-Huber-White's formula. The author used the default behavior of Stata's `robust` command, which includes the HC1 correction, as described in Section 6.4.1 of Peng Ding's lecture notes. Such standard errors relax the homoskedasticity requirement—$\text{Var}\left(\epsilon_i\right) = \sigma^2$—as well as the assumption of normality.

Thus, the only maintained  assumptions are that the linear form in \ref{eq:model1} holds, and that the error terms are independent with mean 0.

## Replication

As the code and the data files were provided completely by the author, we were able to replicate the results perfectly. Table \ref{tab:tbl1Print} perfectly replicates Table 1 in the original paper, and Table \ref{tab:tbl1Info} displays additional information about each model. Note that all variables, including indicators, were standardized by Michalopolous, so we did so here as well. As mentioned above, the reported standard errors are follow the EHW formula, with HC1 correction, so they are generally slightly wider than what one would get from a homoskedastic model. Unsurprisingly, given the increasing number of features, the observed $R^2$ also increases with each model.

```{r standardize1, echo=F}
standardize = function(vec) {return ((vec - mean(vec, na.rm = TRUE)) / sd(vec, na.rm = TRUE))}
 
modelCols = c('entryYear', 'avgTemp', 'avgPrecip', 'seaDist', 'avgElev',
             'sdElev', 'absLat', 'numLang', 'dispSuitable', 'climate',
             'soil', 'sdClimate', 'sdSoil', 'sdSuitable', 'avgSuitable',
             'pop95', 'area', 'lnLang', 'lnPopDens1995', 'migrationDist',
             'lnArea', 'pctIndigenous', 'lnPopDens1500', 'agriTran',
             'americas', 'europe', 'africa', 'asiaPac')
# for (col in modelCols) {
#  data[,col] = standardize(data[,col])
# }
# NOTE: Easier to say what we're not standardizing; also for the robustness checks we need to keep a non-standardized copy
dataStd = data %>% mutate(across(!countryName & !countryCode , standardize))
```

```{r model1.1, echo=F}
model1.1 = lm(lnLang ~ absLat, dataStd)
```

```{r model1.2, echo=F}
model1.2 = lm(lnLang ~ sdElev + sdSuitable + avgElev + avgSuitable + absLat, dataStd)
```

```{r model1.3, echo=F}
model1.3 = lm(lnLang ~ sdElev + sdSuitable + avgElev + avgSuitable + absLat
            + avgPrecip + avgTemp + lnArea + seaDist + migrationDist, dataStd)
```

```{r model1.4, echo=F}
model1.4 = lm(lnLang ~ sdElev + sdSuitable + avgElev + avgSuitable + absLat
            + avgPrecip + avgTemp + lnArea + seaDist + migrationDist + lnPopDens1995
            + africa + europe + americas + asiaPac, dataStd)
```

```{r model1.5, echo=F}
missingData = is.na(dataStd$agriTran) | is.na(dataStd$entryYear) | is.na(dataStd$lnPopDens1500)
for (col in modelCols) {
  dataStd[!missingData, col] = standardize(dataStd[!missingData,col])
}

model1.5 = lm(lnLang ~ sdElev + sdSuitable + avgElev + avgSuitable + absLat
            + avgPrecip + avgTemp + lnArea + seaDist + migrationDist + lnPopDens1995
            + lnPopDens1500 + entryYear + agriTran
            + africa + europe + americas + asiaPac, dataStd, na.action = na.exclude)
```

```{r tbl1, results='hide', echo=F}
models = paste0("model1.", 1:5)
coefs = sapply(models, function(model) {coeftest(get(model), vcov = vcovHC(get(model), "HC1"))[, 1]}) %>% 
  unlist() %>% data.frame()
coefs$model = substr(row.names(coefs), 1, 8)
coefs$column = substr(row.names(coefs), 10, nchar(row.names(coefs)))

ses = sapply(models, function(model) {coeftest(get(model), vcov = vcovHC(get(model), "HC1"))[, 2]}) %>% 
  unlist() %>% data.frame()
ses$model = substr(row.names(ses), 1, 8)
ses$column = substr(row.names(ses), 10, nchar(row.names(ses)))

pvals = sapply(models, function(model) {coeftest(get(model), vcov = vcovHC(get(model), "HC1"))[, 4]}) %>% 
  unlist() %>% data.frame()
pvals$model = substr(row.names(pvals), 1, 8)
pvals$column = substr(row.names(pvals), 10, nchar(row.names(pvals)))

order = c('sdElev', 'sdSuitable', 'avgElev', 'avgSuitable', 'absLat', 
          'avgPrecip', 'avgTemp', 'lnArea', 'seaDist', 'migrationDist',
          'lnPopDens1995', 'lnPopDens1500', 'entryYear', 'agriTran')

pvalsPivoted = pvals %>% pivot_wider(names_from = "model", values_from = '.') %>%
  slice(match(order, column))

tbl1 = rbind(coefs %>% pivot_wider(names_from = "model", values_from = '.'),
             ses %>% pivot_wider(names_from = "model", values_from = '.'))
tbl1$stat = c(rep('Estimate', 19), rep('SE', 19))
indices = c(rbind(match(order, tbl1$column), match(order, tbl1$column) + 19))
tbl1 = tbl1 %>% slice(indices)
```

```{r tbl1Print, results='show', echo=F}
tbl1format = data.frame(tbl1)
for (model in models) {
  estimRows = !is.na(tbl1[, model]) & (tbl1$stat == 'Estimate')
  seRows = !is.na(tbl1[, model]) & (tbl1$stat == 'SE')

  tbl1format[estimRows, model] = sprintf(fmt = "%.3f", tbl1[estimRows, model] %>% unlist() %>% as.numeric())
  tbl1format[seRows, model] = paste0("(", sprintf(fmt = "%.3f", tbl1[seRows, model] %>% unlist() %>% as.numeric()), ")")
  
  significant = rep(pvalsPivoted[, model] < .01, each = 2)
  significant[is.na(significant)] = FALSE
  tbl1format[estimRows, model] = cell_spec(tbl1format[estimRows, model], italic = significant[estimRows])
  tbl1format[seRows, model] = cell_spec(tbl1format[seRows, model], italic = significant[seRows])
}

tbl1format$name = c('Variation in elevation', NA, 'Variation in land quality', NA,
                    'Mean elevation', NA, 'Mean land quality', NA,
                    'Absolute latitude', NA, 'Mean precipitation', NA,
                    'Mean temperature', NA, 'Ln(Area)', NA,
                    'Distance from the sea', NA, 'Migratory distance from Ethiopia', NA,
                    'Ln(Population density in 1995)', NA, 'Ln(Population density in 1500)', NA,
                    'Year of independence', NA, 'Timing of transition to agriculture', NA
                    )

col.names = c("Variable", paste0("(", 1:5, ")"))

tbl1format %>% select(8, 2:6) %>%
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE, linesep = c("", "\\addlinespace"),
             col.names = col.names, align = "r", escape = F,
             caption = 'Main specification for the cross-country analysis. Italics indicate significance at the 1\\% level.') %>%
  row_spec(seq(2, 28, 2), font_size = 8)
```

```{r tbl1Info, results='show', echo=F}
tbl1info = data.frame(
  model = 1:5,
  cont = c("No", "No", "No", "No", "Yes"),
  nobs = sapply(models, function(model) { nobs(get(model))}),
  rsq = sapply(models, function(model) {
    formatC(summary(get(model))$r.squared, digits = 2, format = 'f')
    }), row.names = NULL
  )
tbl1info %>% 
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE,
               col.names = c('Model', 'Continental Indicators', 'Observations', '$R^2$'), escape = F,
               caption = "Information for each model in cross-country analysis.")
```

The interpretation of these results is much the same as in the original paper. In all four models, variation in elevation, and variation in land quality were useful predictors of the log number of languages, as originally hypothesized by the author.

The effects of the geographic variables are also noteworthy. Naturally, the effect of absolute latitude becomes insignificant once precipitation and temperature are introduced, as those two are highly correlated with distance from the equator. Between models 1.1 and 1.2, and also 1.2 and 1.3, the observed $R^2$ makes sizeable jumps, indicating that these geographic features are very useful in explaining linguistic diversity. About the distance distance from sea coefficient, the author has this intruiging interpretation:

> ... areas that are increasingly isolated from the sea have been experiencing limited population mixing and thus should, on average, display higher ethnolinguistic fractionalization. It should be noted, however, that mean distance from the coast also captures the vulnerability of different areas to both the incidence and the intensity of invasion and colonization. Thus, the coefficient should be interpreted cautiously.

As the coefficient was never much more than one standard error above zero anyway, it is easy to ignore this effect entirely.

The final model introduces variables related to a country's history. The log of population density in 1500 does have a significant effect (at larger thresholds), and the author suggests "conditional on geographic characteristics, contemporary ethnic diversity may have been influenced by a country’s historical levels of development." However, the other features entered here are insignificant, and even the sign of the density coefficient goes against intuition. It seems more natural that countries that were denser in 1500 would have greater ethnolinguistic diversity today, simply due to having more people to split, yet the model suggests the opposite. It could also be that this new feature is simply taking the effect of the 1990 density feature, as the two are very strongly correlated. Therefore, we consider it unlikely that such "historical levels of development" have much effect on modern diversity.

Another thing to note is that we noticed some inaccuracies with the provided years of independence. For example, the United States was listed as 1816, as opposed to 1776 or 1783. Other long-existing countries, such as Portugal and Denmark, were also given this 1816 value. Additionally, former Soviet republics were all (correctly) given a year of 1991, further emphasizing that independence year in general is almost arbitrary—it would have been surprising if it had a significant relationship with the outcome.

## Critique of Assumptions

As stated before, this model only requires two main assumptions:

1. The functional form of \ref{eq:model1} is correct.
2. The error terms are independent.

Both assumptions are hard to take fully for granted. Starting with the second, it is likely that there is some spatial correlation between neighboring countries, leading to dependence among the error terms. However, such correlation could have already been sufficiently modeled by including geographic features such as migration distance and average temperature. Additionally, the virtual country analysis, which we will reanalyze in Section \ref{virtual}, shows that the results of the model still hold after abstracting away from established country boundaries.

To informally test the whether or not the linearity assumption holds, Figure \ref{fig:resid1} shows the residual plot for the fifth model. While there is no curved relationship in the plot, it is clear that the residuals tend to increase as the dependent variable increases. This means that there is likely some other feature or combination of features which significantly impacts the log number of languages, which this model does not include. The residuals for the fifth model are what is plotted, but given it is the most specified model, it is expected that residual plots for the other models would look even worse.

Somewhat coincidentally, the residuals do look roughly homoskedastic, even though that assumption was relaxed. Another diagnostic plot that is commonly used is a Normal Q-Q plot of the residuals, but as this model does not require normality, we will not include such a plot here.

```{r resid1, fig.cap="\\label{fig:resid1} Residual Plot for Model 1.5", echo=F, fig.width = 6.5, fig.height=3}
yhat = model1.5$residuals
y = model1.5$model$lnLang
plot(y, yhat, xlab = "", ylab = "", cex.axis = .75)
title(ylab = "Residuals", xlab = "Ln(Number of Languages)", mgp = c(2, .5, 0), cex.lab = .75)
residModel = lm(yhat ~ y)
abline(0, 0)
lines(y, y * residModel$coefficients['y'], col = 'red', type = 'l')
```


# Robustness Check of Analysis 1

## Table 2A

```{r model1.1Rob, results='hide', echo=F, eval=T}
robust1.1 <- glm.nb(numLang ~ absLat + sdSuitable + sdElev + avgElev + avgSuitable + avgPrecip + avgTemp + lnArea 
                    + seaDist + migrationDist + lnPopDens1995 + lnPopDens1500 + entryYear + agriTran + 
                      africa + europe + americas + asiaPac
                    , data, na.action = na.exclude)
```

```{r model1.1RobTable, results='show', echo=F, eval=T}
summary(robust1.1)
```
NOTE: Matches!


```{r model1.2Rob, results='hide', echo=F, eval=T}
robust1.2 <- lm(lnLang ~ absLat + dispElev + dispSuitable + avgElev + avgSuitable + avgPrecip +  avgTemp +  
                lnArea +  seaDist + migrationDist +  lnPopDens1995 + lnPopDens1500 + entryYear + agriTran + 
                africa + europe + americas + asiaPac,
                data, na.action = na.exclude)
                    
```

```{r model1.2RobTable, results='show', echo=F, eval=T}
summary(robust1.2)
```
NOTE: matches or exceeds in significance, as well

```{r model1.3Rob, results='hide', echo=F, eval=T}
robust1.3 <- lm(lnLang ~ absLat + sdElev + sdClimate + avgElev + climate + avgPrecip +  avgTemp +  
                lnArea +  seaDist + migrationDist +  lnPopDens1995 +  lnPopDens1500 + entryYear + agriTran + 
                africa + europe + americas + asiaPac,
                data, na.action = na.exclude)
                    
```

```{r model1.3RobTable, results='show', echo=F, eval=T}
summary(robust1.3)
```

NOTE: matches!


```{r model1.4Rob, results='hide', echo=F, eval=T}
# NOTE: the conditional doesn't remove anything from the `data` df
data1.4 <- data[(data$suitableCells > 9) & (data$lnArea > -10), ]

robust1.4 <- lm(lnLang ~ absLat + sdElev + sdSoil + avgElev + soil + avgPrecip +  avgTemp +  
                lnArea +  seaDist + migrationDist +  lnPopDens1995 +  lnPopDens1500 + entryYear + agriTran + 
                africa + europe + americas + asiaPac,
                data1.4, na.action = na.exclude)
                    
```

```{r model1.4RobTable, results='show', echo=F, eval=T}
summary(robust1.4)
```
NOTE: matches!


## Table 2B

```{r data_import2b, echo=F, eval=T}
data2b <- read.dta13("data_raw/Table_3b.dta")

standardized <- list("lpd1500", "yrentry", "agritran", "elf", "elf3", "elf5", "elf7", "elf9",
                     "abs_lat", "sd_climsuit", "sd_emean", "emean", "mean_climsuit", "precav",
                     "tempav", "lnareakm2", "distc", "migdist", "lnpop95", "americas", "reg_eap",
                     "africa", "europe", "nmbr_climsuit")

notStdized <- names(data2b)[! names(data2b) %in%  standardized]
data2bStd <- data2b %>% mutate(across(! all_of(notStdized) , standardize))

```

`TODO: write up a bit about the datasets used here`


```{r model1.2.1, results='hide', echo=F, eval=T}
robust1.2.1 <- lm(elf ~ abs_lat, data2bStd, na.action = na.exclude)

```

```{r model1.2.1Table, results='show', echo=F, eval=T}
summary(robust1.2.1)
```

OK

```{r model1.2.2, results='hide', echo=F, eval=T}
robust1.2.2 <- lm(elf ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit,
                  data2bStd, na.action = na.exclude)

```

```{r model1.2.2Table, results='show', echo=F, eval=T}
summary(robust1.2.2)
```
OK


```{r model1.2.3, results='hide', echo=F, eval=T}
robust1.2.3 <- lm(elf ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit + 
                  precav + tempav + lnareakm2 + distc + migdist + lnpop95 + lpd1500 + yrentry + agritran + 
                  africa + europe + americas + reg_eap
                  , data2bStd, na.action = na.exclude)

```

```{r model1.2.3Table, results='show', echo=F, eval=T}
summary(robust1.2.3)
```
OK

```{r model1.2.4, results='hide', echo=F, eval=T}
robust1.2.4 <- lm(elf3 ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit + 
                  precav + tempav + lnareakm2 + distc + migdist + lnpop95 + lpd1500 + yrentry + agritran + 
                  africa + europe + americas + reg_eap
                  , data2bStd, na.action = na.exclude)

```

```{r model1.2.4Table, results='show', echo=F, eval=T}
summary(robust1.2.4)
```

OK

```{r model1.2.5, results='hide', echo=F, eval=T}
robust1.2.5 <- lm(elf5 ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit + 
                  precav + tempav + lnareakm2 + distc + migdist + lnpop95 + lpd1500 + yrentry + agritran + 
                  africa + europe + americas + reg_eap
                  , data2bStd, na.action = na.exclude)

```

```{r model1.2.5Table, results='show', echo=F, eval=T}
summary(robust1.2.5)
```

OK


```{r model1.2.6, results='hide', echo=F, eval=T}
robust1.2.6 <- lm(elf7 ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit + 
                  precav + tempav + lnareakm2 + distc + migdist + lnpop95 + lpd1500 + yrentry + agritran + 
                  africa + europe + americas + reg_eap
                  , data2bStd, na.action = na.exclude)

```

```{r model1.2.6Table, results='show', echo=F, eval=T}
summary(robust1.2.6)
```

OK


```{r model1.2.7, results='hide', echo=F, eval=T}
robust1.2.7 <- lm(elf9 ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit + 
                  precav + tempav + lnareakm2 + distc + migdist + lnpop95 + lpd1500 + yrentry + agritran + 
                  africa + europe + americas + reg_eap
                  , data2bStd, na.action = na.exclude)

```

```{r model1.2.Table, results='show', echo=F, eval=T}
summary(robust1.2.7)
```

OK

# Analysis 2: Virtual Country (Re-Analysis)  \label{virtual}

The second analysis Michalopolous presents in his paper is essentially a repeat of the the first, but instead aggregating geographic and ethnic information over "virtual" countries instead of real ones. The stated motivation for this is "to investigate whether the relationship between geography and ethnic diversity holds true at an arbitrary level of aggregation."

As with the previous analysis, the geographic features are derived from a dataset of cells, each of size .5-by.5 decimal degrees. However, instead of aggregating these cells at the country level as before, we now split up the world into blocks of size 2.5-by-2.5 decimal degrees, with each block containing 25 cells. Each block is precisely a "virtual country."

To obtain the number of languages in each virtual country, Michalopolous simply intersected the shapefile provided in the World Language Mapping System with the newly-formed grid. However, probably due to the proprietary nature of the WLMS, the "number of languages" variable was withheld from the public data download, meaning we could not exactly replicate the analysis.

Fortunately, we stumbled across the *Geo-referencing of Ethnic Groups* (GREG) dataset [@weidmann_representing_2010], which contains a shapefile of the locations of 928 ethnic groups across the world. As Michalopolous was only using linguistic diversity as a proxy for ethnic diversity, we decided it would be useful to model ethnic diversity directly, to see if the original paper's results held up with the GREG data.

## Data Cleaning

The original GREG dataset required some manipulation to get it in a format suitable to swap in for the WLMS. Each polygonwas labeled with up to three ethnic groups, so we had to melt and then dissolve the polygons such that each polygon represented only one ethnic group, and each ethnic group was only assigned to one polygon. For details, see the appendix, which shows the geoprocessing steps performed with the `geopandas` module in Python.

In the original paper, Michalopolous described the steps he took to filter the virtual countries, on criteria mostly based on the amount of "coverage" each country had in the WLMS data. If a large portion of a virtual country was an area which contained no languages—for example, the Sahara Desert—that virtual country was excluded from the analysis. The public data download, which contained the virtual countries after this filter had been applied, contained 1,888 virtual countries. Due to differences in coverage between WLMS and GREG, applying the same criteria to GREG would have resulted in 2,476 countries. Including these additional countries would have required obtaining the other features for these areas, and as Michalopolous did not document this procedure well, we decided that this was not feasible. The end result was that our dataset only included the intersection of the sets derived WLMS and GREG, which excluded the ~600 countries from the dataset derived from GREG, but also about 30 countries that had enough coverage in WLMS, but did not in GREG.

Finally, the actual regressions performed in the paper used a dataset that was further filtered down. That is, there must have been at least 3000 people living in the virtual country in 1995, and at least 10 of the 25 cells that comprise a virtual country had to have been completely covered by the WLMS dataset. We applied both of these criteria here as well when reproducing the regressions.

## Replication

The model specification for this analysis is almost exactly the same as before, except now each unit $i$ is a virtual country, and "numLang" is really the number of unique ethnic groups:

\begin{equation} \label{eq:model2}
\ln\left(\text{numLang}_i\right) = \beta_0 + \beta_1*\text{absLat}_i + \beta_2*\text{sdElev}_i + \beta_3*\text{sdSuitable}_i + \beta_4* X_i + \epsilon_i
\end{equation}

Additionally, regressions 2.5, 2.6, and 2.7 are performed only on virtual countries meeting a certain criterion. Regression 2.5 looks only at virtual countries located in the tropics, 2.6 looks at countries not located in the tropics, and 2.7 filters to virtual countries that are located entirely within a real country.

```{r dataImport2, echo=F}
data2 = read.dta13('data_raw/Tables4-7b.dta')
greg = read.csv('greg.csv')
colnames(greg) = c('uniq_cnt25', 'number_suit_valid25', 'nmbrlang')

data2 = data2 %>% select(-c('nmbrlang', 'number_suit_valid25')) %>% merge(greg, by = 'uniq_cnt25')

data2$lnnmbrlang = log(data2$nmbrlang)
```

```{r rename2, echo=F}
colnames(data2) = c('virtCode', 'countryCode', 'climate', 'soil',
                   'sdClimate', 'sdSoil', 'seaDist', 'avgElev', 'avgPrecip',
                   'avgTemp', 'sdElev', 'waterArea', 'avgSuitable',
                   'sdSuitable', 'popDens95', 'range', 'area', 'withinCountry', 
                   'numCountry', 'migrationDist', 'lnLang', 'totalPop95',
                   'absLat', 'tropics', 'erange_gecon', 'lnArea', 
                   'lnPopDens95', 'pctIndigenous', 'diffAvgElev',
                   'diffAvgPrecip', 'diffAvgTemp', 'diffAvgSuit',
                   'overlap', 'suitableCells', 'numLang')

modelCols = c('lnLang', 'sdElev', 'sdSuitable', 'avgElev', 'avgSuitable',
              'absLat', 'avgPrecip', 'avgTemp', 'lnArea', 'seaDist', 'waterArea',
              'withinCountry', 'numCountry', 'migrationDist', 'lnPopDens95')
```


```{r model2.1, echo=F}
condition = (data2$totalPop95 >= 3000) & (data2$suitableCells >= 10)
for (col in modelCols) {
  data2[condition, paste0(col, '1')] = standardize(data2[condition, col])
}
model2.1 = lm(lnLang1 ~ absLat1, data2 %>% filter(condition))
coefs = coeftest(model2.1, vcov = vcovCL, cluster = ~countryCode)[, 1]
ses = coeftest(model2.1, vcov = vcovCL, cluster = ~countryCode)[, 2]
pvals = coeftest(model2.1, vcov = vcovCL, cluster = ~countryCode)[, 4]
```

```{r model2.2, echo=F}
model2.2 = lm(lnLang1 ~ sdElev1 + sdSuitable1 + avgElev1 + avgSuitable1 + absLat1,
            data2 %>% filter(condition))
coefs = c(coefs, coeftest(model2.2, vcov = vcovCL, cluster = ~countryCode)[, 1])
ses = c(ses, coeftest(model2.2, vcov = vcovCL, cluster = ~countryCode)[, 2])
pvals = c(pvals, coeftest(model2.2, vcov = vcovCL, cluster = ~countryCode)[, 4])
```

```{r model2.3, echo=F}
model2.3 = lm(lnLang1 ~ sdElev1 + sdSuitable1 + avgElev1 + avgSuitable1 + absLat1
            + avgPrecip1 + avgTemp1 + lnArea1 + seaDist1 + waterArea1
            + withinCountry1 + numCountry1 + migrationDist1,
            data2 %>% filter(condition))
coefs = c(coefs, coeftest(model2.3, vcov = vcovCL, cluster = ~countryCode)[, 1])
ses = c(ses, coeftest(model2.3, vcov = vcovCL, cluster = ~countryCode)[, 2])
pvals = c(pvals, coeftest(model2.3, vcov = vcovCL, cluster = ~countryCode)[, 4])
```


```{r model2.4, echo=F}
model2.4 = lm_robust(lnLang1 ~ sdElev1 + sdSuitable1 + avgElev1 + avgSuitable1 + absLat1
            + avgPrecip1 + avgTemp1 + lnArea1 + seaDist1 + waterArea1
            + withinCountry1 + numCountry1 + migrationDist1 + lnPopDens951,
            data2 %>% filter(condition),
            fixed_effects = ~countryCode, se_type = "stata")
coefs = c(coefs, 0, model2.4$coefficients)
ses = c(ses, 0, model2.4$std.error)
pvals = c(pvals, 0, model2.4$p.value)
```

```{r model2.5, echo=F}
condition = (data2$totalPop95 >= 3000) & (data2$suitableCells >= 10) & (data2$tropics == 1)
for (col in modelCols) {
  data2[condition, paste0(col, '5')] = standardize(data2[condition, col])
}
model2.5 = lm_robust(lnLang5 ~ sdElev5 + sdSuitable5 + avgElev5 + avgSuitable5 + absLat5
            + avgPrecip5 + avgTemp5 + lnArea5 + seaDist5 + waterArea5
            + withinCountry5 + numCountry5 + migrationDist5 + lnPopDens955,
            data2 %>% filter(condition),
            fixed_effects = ~countryCode, se_type = "stata")
coefs = c(coefs, 0, model2.5$coefficients)
ses = c(ses, 0, model2.5$std.error)
pvals = c(pvals, 0, model2.5$p.value)
```

```{r model2.6, echo=F}
condition = (data2$totalPop95 >= 3000) & (data2$suitableCells >= 10) & (data2$tropics == 0)
for (col in modelCols) {
  data2[condition, paste0(col, '6')] = standardize(data2[condition, col])
}
model2.6 = lm_robust(lnLang6 ~ sdElev6 + sdSuitable6 + avgElev6 + avgSuitable6 + absLat6
            + avgPrecip6 + avgTemp6 + lnArea6 + seaDist6 + waterArea6
            + withinCountry6 + numCountry6 + migrationDist6 + lnPopDens956,
            data2 %>% filter(condition),
            fixed_effects = ~countryCode, se_type = "stata")
coefs = c(coefs, 0, model2.6$coefficients)
ses = c(ses, 0, model2.6$std.error)
pvals = c(pvals, 0, model2.6$p.value)
```

```{r model2.7, echo=F}
condition = (data2$totalPop95 >= 3000) & (data2$suitableCells >= 10) & (data2$withinCountry == 1)
for (col in modelCols) {
  data2[condition, paste0(col, '7')] = standardize(data2[condition, col])
}
model2.7 = lm_robust(lnLang7 ~ sdElev7 + sdSuitable7 + avgElev7 + avgSuitable7 + absLat7
            + avgPrecip7 + avgTemp7 + lnArea7 + seaDist7 + waterArea7
            + migrationDist7 + lnPopDens957,
            data2 %>% filter(condition),
            fixed_effects = ~countryCode, se_type = "stata")
coefs = c(coefs, 0, model2.7$coefficients)
ses = c(ses, 0, model2.7$std.error)
pvals = c(pvals, 0, model2.7$p.value)
```


```{r tbl4, results='hide', echo=F}
models = paste0("model2.", 1:7)

names(coefs)[names(coefs) == ""] = "(Intercept)"
coefs = data.frame(coefs, row.names = paste0("model2.", cumsum(names(coefs) %in% c("(Intercept)", "")), ".", names(coefs)))
coefs$model = substr(row.names(coefs), 1, 8)
coefs$column = substr(row.names(coefs), 10, nchar(row.names(coefs)) - 1)

names(ses)[names(ses) == ""] = "(Intercept)"
ses = data.frame(ses, row.names = paste0("model2.", cumsum(names(ses) %in% c("(Intercept)", "")), ".", names(ses)))
ses$model = substr(row.names(ses), 1, 8)
ses$column = substr(row.names(ses), 10, nchar(row.names(ses)) - 1)

names(pvals)[names(pvals) == ""] = "(Intercept)"
pvals = data.frame(pvals, row.names = paste0("model2.", cumsum(names(pvals) %in% c("(Intercept)", "")), ".", names(pvals)))
pvals$model = substr(row.names(pvals), 1, 8)
pvals$column = substr(row.names(pvals), 10, nchar(row.names(pvals)) - 1)

order = c('sdElev', 'sdSuitable', 'avgElev', 'avgSuitable', 'absLat',
          'avgPrecip', 'avgTemp', 'lnArea', 'seaDist', 'waterArea',
          'withinCountry', 'numCountry', 'migrationDist', 'lnPopDens95')

pvalsPivoted = pvals %>% pivot_wider(names_from = "model", values_from = 'pvals') %>% 
  slice(match(order, column))

tbl4 = rbind(coefs %>% pivot_wider(names_from = "model", values_from = 'coefs'), 
             ses %>% pivot_wider(names_from = "model", values_from = 'ses'))
tbl4$stat = c(rep('Estimate', 15), rep('SE', 15))
indices = c(rbind(match(order, tbl4$column), match(order, tbl4$column) + 15))
tbl4 = tbl4 %>% slice(indices)
```

```{r tbl4Print, results='show', echo=F}
tbl4format = data.frame(tbl4)
for (model in models) {
  estimRows = !is.na(tbl4[, model]) & (tbl4$stat == 'Estimate')
  seRows = !is.na(tbl4[, model]) & (tbl4$stat == 'SE')

  tbl4format[estimRows, model] = sprintf(fmt = "%.3f", tbl4[estimRows, model] %>% unlist() %>% as.numeric())
  tbl4format[seRows, model] = paste0("(", sprintf(fmt = "%.3f", tbl4[seRows, model] %>% unlist() %>% as.numeric()), ")")
  
  significant = rep(pvalsPivoted[, model] < .01, each = 2)
  significant[is.na(significant)] = FALSE
  tbl4format[estimRows, model] = cell_spec(tbl4format[estimRows, model], italic = significant[estimRows])
  tbl4format[seRows, model] = cell_spec(tbl4format[seRows, model], italic = significant[seRows])
}

tbl4format$name = c('Variation in elevation', NA, 'Variation in land quality', NA,
                           'Mean elevation', NA, 'Mean land quality', NA,
                           'Absolute latitude', NA, 'Mean precipitation', NA,
                           'Mean temperature', NA, 'Ln(Area)', NA,
                           'Distance from the sea', NA, 'Water area', NA,
                         'Within-country indicator', NA, 'Number of countries', NA,
                         'Migratory distance from Ethiopia', NA, 'Ln(Population density in 1995)', NA)

col.names = c("Variable", paste0("(", 1:7, ")"))

tbl4format %>% select(10, 2:8) %>%
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE, linesep = c("", "\\addlinespace"),
             col.names = col.names, align = "r", escape = F,
             caption = 'Main specification for the virtual country analysis. Italics indicate significance at the 1\\% level.') %>%
  row_spec(seq(2, 28, 2), font_size = 8)
```


```{r tbl4Info, results='show', echo=F}
tbl4info = data.frame(
  model = 1:7,
  cont = c("No", "No", "No", "Yes", "Yes", "Yes", "Yes"),
  nobs = sapply(models, function(model) { nobs(get(model))}),
  rsqOG = formatC(c(.31, .36, .53, .70, .73, .56, .66), digits = 2, format = 'f'),
  rsq = sapply(models, function(model) {
    formatC(summary(get(model))$r.squared, digits = 2, format = 'f')
    }), 
  row.names = NULL
  )
tbl4info %>% 
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE,
               linesep = c(""), align = 'r',
               col.names = c('Model', 'Country Indicators', 'Observations', 'WLMS $R^2$', 'GREG $R^2$'), escape = F,
               caption = "Information for each model in virtual country analysis.")
```

Table \ref{tab:tbl4Print} shows the results of regressing the log of number of ethnic groups on different sets of features, reproducing Table 4 of the original paper. Note that the features here are very similar to the ones used in the cross-country analysis. The only differences are that features directly relating to real countries, such as independence year, have been swapped for features describing the position of the virtual country in relation to real countries. Table \ref{tab:tbl4Info} shows information about each model, including the observed $R^2$ in the original WLMS regression, and our GREG regression.

Here, the reported standard errors are cluster-robust, with the clusters defined by the real country in which the centroid of each virtual country falls. Whether Stata applies any corrections by default is unclear, but the base formula should be the same as the one described in Section 24.4.1 of Peng Ding's lecture notes, which we implemented in R using the `sandwich` and `lmtest` packages. Michalopolous did not justify his decision to cluster by real country, and the reader would not know that he did so without checking the footnotes or his code. However, it seems a reasonable decision, considering that virtual countries within the same real country are certainly related beyond any similarities in their features.

Additionally, models 2.4 through 2.7 use country fixed effects. Again, exactly how to replicate the Stata code was not obvious, but the `lm_robust` function from the `estimatr` package appeared to work. This technique essentially just includes one indicator variable for each real country in the model, and then ignores the estimates for those variables in the output. Per Michalopolous:

> Such inclusion of powerful controls, not possible in a cross-country framework, allows me to explicitly take into account any systematic elements related to the nation-building process of current states and thus produce reliable estimates of the effect of geographic heterogeneity on ethnic diversity.

## Comparison

One major difference between GREG and WLMS is that the footprint of each unique ethnic group in GREG are larger than that for each unique language in the WLMS. This makes sense, considering that GREG only contains about 900 entries, yet there are a few thousand unique languages in the WLMS. As a result, the dependent variable is generally a lot smaller in our replication compared to that in the original paper. Michalopolous reports the median number of languages per virtual country as 3, yet here, more than half of the virtual countries contain only one ethnic group. A possible solution to adjust for this would be to simply reduce the size of the virtual countries, but this was infeasible due to our inability to recalculate the rest of the features.

As for the actual results, the first noticeable difference is that of the $R^2$ coefficients. In all models, the $R^2$ is considerably lower in our replication compared to the original, although the differences are smaller for the models including country fixed effects. For example, absolute latitude on its own explains just 4% of the variation in log number of ethnic groups, compared to 33% in the original. However, the coefficient is still significant at the 1% level and ha negative sign, as it does in the original.

Beyond the worse fits overall, the inference around the coefficients does not differ much between the two models. If a variable is significant at the 1% level in one model, there is a good chance it is significant at at least the 5% or 10% level in its counterpart, or vice versa. Variation in elevation and variation in land quality continue to have a large relationship with the outcome, leading further evidence to the author's original hypothesis. The number of real countries intersected by a virtual country is also a really strong predictor in both sets of models. Michalopolous ponders that this "may be suggestive of the effect of state formation on ethnic diversity and/or an artifact of modern states having drawn political borders along ethnic boundaries." This certainly seems reasonable, but given how diminished the effects of some of the other variables are in our replication, it is surprising that this one is still so large. Perhaps this is another artifact of the aforementioned reduced granularity of GREG compared to WLMS, that ethnic groups are even more strongly correlated with national boundaries than languages are.

However, there are a few noteworthy inconsistencies. One is that distance from the sea is significant for every model here, but only for model 2.5 (tropical locations) in the original. Another oddity of the tropical model is that the sign for variation in elevation flips to negative, and log of population density becomes a strong predictor. Without speculating on real-world phenomena, one reason for this could be differences in how virtual countries in tropical areas were filtered in the GREG dataset compared to WLMS.

## Robustness Check

```{r model2.1Rob, results='hide', echo=F, eval=F}
condition = (data2$totalPop95 >= 3000) & (data2$suitableCells >= 10)
# NOTE: see "Table 7A" in the code
for (col in modelCols) {
  data2[condition, paste0(col, '1')] = standardize(data2[condition, col])
}

robust2.1 <-  glm.nb(lnLang1 ~ sdElev1 + sdSuitable1 + avgElev1 + avgSuitable1 + absLat1
                    + avgPrecip1 + avgTemp1 + lnArea1 + seaDist1 + waterArea1
                    + withinCountry1 + numCountry1 + migrationDist1 + lnPopDens951,
                    data2 %>% filter(condition)
                    , na.action = na.exclude)
```

```{r model2.1RobTable, results='show', echo=F, eval=F}
summary(robust1.1)
```





# References

<div id="refs"></div>


\newpage
# Appendix: code
<!-- NOTE: add code chunks to be displayed here -->
```{r codeAppendix, ref.label=c('dataImport1', 'rename1', 'greeceNepal', 'worldMap', 'summary', 'standardize1', 'model1.1', 'model1.2', 'model1.3', 'model1.4', 'model1.5', 'tbl1', 'tbl1Print', 'tbl1Info', 'resid1', 'model1.1Rob', 'model1.2Rob', 'model1.3Rob', 'model1.4Rob', 'data_import2b', 'model1.2.1', 'model1.2.2', 'model1.2.3', 'model1.2.4', 'model1.2.5', 'model1.2.6', 'model1.2.7', 'dataImport2', 'rename2', 'model2.1', 'model2.2', 'model2.3', 'model2.4', 'model2.5', 'model2.6', 'model2.7', 'tbl4', 'tbl4Print', 'tbl4Info'), echo=T, eval=F}

```








