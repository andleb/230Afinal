---
title: |
  | STAT 230A Final Project
  | Replication of Michalopoulos: The Origins of Ethnolinguistic Diversity
author: 
  - Andrej Leban, andrej_leban@berkeley.edu
  - Isaac Schmidt, ischmidt20@berkeley.edu
email: 
  - "andrej_leban@berkeley.edu"
  - "ischmidt20@berkeley.edu"
# nocite: | 
#   @ding_linear_2022
# date: "`r format(Sys.time(), '%B %d, %Y')`"
header-includes:
  - \usepackage{float, amsthm, amsmath, amssymb, bm, enumitem, latexsym, color, minipage-marginpar, caption, multirow, verbatim, xcolor, setspace, fancyhdr}
geometry: margin=1in
# linestretch: 1.5
output:
  pdf_document:
    # TODO: enable for the final writeup
    toc: yes
    number_sections: true
    df_print: kable
papersize: a4
urlcolor: blue
bibliography: [references.bib]
editor_options:
  markdown:
    wrap: 120
always_allow_html: true
---

```{r setup, echo = FALSE, message=FALSE, warning=FALSE}
library(conflicted)
library(gdata)
library(MASS)
library(sandwich)
library(lmtest)
library(estimatr)
library(gee)
library(geeM)

# extra:
library(gsubfn)
library(reshape2)

library(data.table)

library(knitr)
library(kableExtra)
library(ggrastr)

library(readstata13)
library(sf)

library(viridis)
library(tidyverse)

# NOTE: this is to make only the displayed code smaller
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr") 

# set default knitr chunks
knitr::opts_chunk$set(
  echo = TRUE,
  fig.align = "center",
  fig.height = 4,
  fig.pos = "h!",
  fig.width = 6,
  message = FALSE,
  warning = FALSE,
  cache = F,
  results = 'hide', 
  size="small"
)

options(knitr.kable.NA = '')

# define my_theme - append here
my_theme <- theme_minimal()
```

<!-- LaTeX preamble -->
\newcommand{\E}{{\mathbb E}}
\newcommand{\se}{{\mathcal{E}}}
\newcommand{\R}{{\mathbb R}}
\renewcommand{\P}{{\mathbb P}}
\newcommand{\ac}{{\mathcal{A}}}
\newcommand{\A}{{\mathcal{A}}}
\newcommand{\B}{{\mathcal{B}}}
\newcommand{\T}{{\mathcal{T}}}
\newcommand{\Z}{{\mathcal{Z}}}
\newcommand{\K}{{\mathcal{K}}}
\newcommand{\lc}{{\mathcal{L}}}
\newcommand{\Ps}{{\mathcal{P}}}
\newcommand{\pa}{{\mathring{p}}}
\newcommand{\F}{{\cal F}}
\newcommand{\samp}{{\mathcal{X}}}
\newcommand{\X}{{\mathcal{X}}}
\newcommand{\hi}{{\hat{\Phi}}}

\def\qt#1{\qquad\text{#1}}

\def\argmin{\mathop{\rm argmin}}
\def\argmax{\mathop{\rm argmax}}

\setlength{\parskip}{1.4 \medskipamount}

\onehalfspacing

\pagestyle{fancy}
\fancypagestyle{plain}{\pagestyle{fancy}}
\fancyhead[R]{Group 29: Andrej Leban, Isaac Schmidt}



```{r dataImport1, echo=F}
cells = read_sf(dsn = 'data_raw/Virtual_country', layer = 'virtual_cntrygrid')
countries = read_sf(dsn = 'countries', layer = 'countries')
data = read.dta13("data_raw/Tables1-3a.dta")
```

```{r rename1, echo=F}
colnames(data) = c('countryCode', 'entryYear', 'countryName', 'avgTemp', 
                   'avgPrecip', 'seaDist', 'avgElev', 'sdElev', 'absLat', 
                   'dispElev', 'numLang', 'suitableCells', 'dispSuitable',
                   'climate', 'soil', 'sdClimate', 'sdSoil', 'sdSuitable', 
                   'avgSuitable', 'pop95', 'area', 'lnLang', 'africa', 
                   'europe', 'americas', 'lnPopDens1995', 'migrationDist', 
                   'lnArea', 'pctIndigenous', 'lnPopDens1500', 
                   'agriTran', 'asiaPac')
```

# Paper Summary & Summary Statistics Table

## Paper Summary

The paper by Michalopoulos [@michalopoulos_origins_2012] aims to explain ethnolinguistic diversity within and across countries by assuming that a proxy quantity—the number of languages per square kilometer—is determined by a selection of various economic, historical, and geographic variables. It determines that *variation in regional land quality* and *variation in elevation* are the most significant determinants of linguistic diversity. The hypothesis underpinning this examination is that differences in local land characteristics induce different levels of human capital across locations, which in turn, gives rise to localized ethnicities that are characterized by separate languages. The results of the empirical study presented are found to be consistent with this hypothesis.

The empirical results are obtained separately by three regressions:  

* **Cross-country**: this takes the current political borders as the unit within which covariates such as the number of languages are counted.

* **Virtual countries**: To account for the arbitrary nature of some political boundaries with respect to ethnolinguistic groupings, the world is split into arbitrary *virtual countries* and the regression is performed again.
  
* **Adjacent regions**: To account for a potentially high "baseline" effect in some regions, adjacent regions are compared directly, which neutralizes region-specific fixed effects and focuses on the effect of the variables under consideration.
  
<!-- NOTE: I don't think we ever did this in the replication:
Finally, in regions that have undergone a major demographic shift in the last 500 years, the explanatory power of the model -->
<!-- is found to be significantly weaker; these regions are controlled for with a dummy variable. -->

## Exploratory Data Analysis and Summary Table

The data comes from multiple sources: the standard geographic data was sourced from the *Geographically Based Economic Data database*, the data on land quality for agriculture comes from *Ramankutty et al. (2002)*, and the data on the distribution of languages comes from the *World Language Mapping System*. Fortunately, the data provided by the author was already processed and cleaned to the extent used in the paper, so all we did was rename columns to more descriptive names.

The paper lacks a true summary table and shows a couple of EDA figures instead. We replicate two of those figures, and then display our own summary table of the features used in the paper's first regression—the *cross-country model*. Figure \ref{fig:suit} shows the distribution of land suitability for agriculture across the world at a resolution of .5-by.5 decimal degrees. The dependent variable represents the probability that a particular grid cell may be cultivated. 

```{r fig1, fig.cap="\\label{fig:suit} Land quality for agriculture across countries", echo=F, cache=T, fig.width = 6, fig.height=4}
fig1 = ggplot(cells) + rasterize(geom_sf(aes(fill = suit_new), colour = NA), dpi=450) +
  scale_fill_viridis_c("Land quality", direction = -1 ) + my_theme
fig1
```

```{r greeceNepal, cache=TRUE, echo=F}
greeceCells = countries %>% filter(COUNTRY == 'Greece') %>%
  st_intersection(y = cells)
nepalCells = countries %>% filter(COUNTRY == 'Nepal') %>%
  st_intersection(y = cells)
```

Figure \ref{fig:kde1} shows the distribution of land quality within two countries selected in the paper—Greece and Nepal, obtained with a kernel density estimate using the Epanechnikov kernel.

```{r worldMap, fig.cap="\\label{fig:kde1} Kernel density of land quality in Greece and Nepal", echo=F, fig.width = 5, fig.height=3}
plot(
  density(greeceCells$suit_new, kernel = "epanechnikov"),
  xlim = c(0, 1),
  xlab = 'Land quality per region',
  ylab = 'Density',
  main = '',
  lty = 2
)
lines(density(nepalCells$suit_new, kernel = "epanechnikov"), col = 'red')
legend(
  .1,
  3,
  legend = c(
    'Distribution of land quality in Greece',
    'Distribution of land quality in Nepal'
  ),
  col = c("black", "red"),
  lty = 2:1,
  cex = .75
)
```

Table \ref{tab:summaryPrint} shows summary statistics of important variables for the first model. The dependent variable is `numLang`, which is the number of languages whose "traditional homeland" intersects with the country's boundary. Additional covariates are measures of centrality and variability of the geographic data, the log of the country's 1995 population, human migration distance from Africa, and the distance from a large body of water. 
While some other variables in the provided dataset have missing values for some countries, we note that all variables
included in the first regression are known for all countries.  

```{r summary, results='hide', echo=F}
count = function(x) {
  (sum( ~ is.na(x)))
}

sumTable <- data %>% select(
  c(
    'numLang',
    'sdElev',
    'sdSuitable',
    'avgElev',
    'avgSuitable',
    'absLat',
    'avgPrecip',
    'avgTemp',
    'lnArea',
    'seaDist',
    'migrationDist',
    'lnPopDens1995'
  )
) %>%
  summarise_each(
    funs(
      min = min,
      median = median,
      max = max,
      mean = mean,
      iqr = quantile(., 0.75) - quantile(., 0.25),
      sd = sd,
      n = sum(!is.na(.))
    )
  ) %>%
  gather(var, val) %>%
  separate(var, into = c("var", "stat"), sep = "_") %>%
  spread(var, val) %>% column_to_rownames(var = "stat") %>%
  select(
    c(
      'numLang',
      'sdElev',
      'sdSuitable',
      'avgElev',
      'avgSuitable',
      'absLat',
      'avgPrecip',
      'avgTemp',
      'lnArea',
      'seaDist',
      'migrationDist',
      'lnPopDens1995'
    )
  ) %>%
  mutate_if(is.numeric, ~ round(., 2)) %>% slice(5, 4, 2, 3, 7)
```

```{r summaryPrint, results='show', echo=F}
knitr::kable(sumTable, toprule = '', bottomrule = '', booktabs = TRUE, linesep = c(""), caption = 'Summary statistics for covariates in cross-country analysis') %>% row_spec(0, angle = 90)
```


# Analysis 1: Cross-Country

The first model regresses the (log) number of languages within each country on the features described above. Michalopolous presents five different regression models, each containing a different number of covariates. The model, as described in the original paper, is the following:

\begin{equation} \label{eq:model1}
\ln\left(\text{numLang}_i\right) = \beta_0 + \beta_1*\text{absLat}_i + \beta_2*\text{sdElev}_i + \beta_3*\text{sdSuitable}_i + \beta_4* X_i + \epsilon_i
\end{equation}

The first model only includes absolute latitude, the second model adds the mean and standard deviation of both elevation and land quality within each country, and the remaining models add additional covariates represented by $X_i$.

## Statement of Assumptions

The canonical assumptions of a linear model are that Equation \ref{eq:model1} actually is the data-generation process, and that the error terms $\epsilon_i$ are normal with mean 0, and constant variance $\sigma^2$. Of course, these assumptions are rarely actually true, but fortunately, they can be relaxed slightly.

In the original paper, Michalopolous reported "robust" standard errors for the estimated coefficients, following Eicker-Huber-White's formula. The author used the default behavior of Stata's `robust` command, which includes the HC1 correction, as described in Section 6.4.1 of Peng Ding's lecture notes [@ding_linear_2022]. Such standard errors relax the homoskedasticity requirement—$\text{Var}\left(\epsilon_i\right) = \sigma^2$—as well as the assumption of normality.

Thus, the only maintained  assumptions are that the linear form in \ref{eq:model1} holds, and that the error terms are independent with mean 0.

## Replication

As the code and the data files were provided completely by the author, we were able to replicate the results perfectly. Table \ref{tab:tbl1Print} perfectly replicates Table 1 in the original paper, and Table \ref{tab:tbl1Info} displays additional information about each model. Note that all variables, including indicators, were standardized by Michalopolous, so we did so here as well. As mentioned above, the reported standard errors follow the EHW formula with HC1 correction,
so they are generally slightly larger than those one would obtain from a homoskedastic model. Unsurprisingly, given the
increasing number of features, the observed $R^2$ also increases with each model.

```{r standardize1, echo=F}
standardize = function(vec) {return ((vec - mean(vec, na.rm = TRUE)) / sd(vec, na.rm = TRUE))}
 
modelCols = c('entryYear', 'avgTemp', 'avgPrecip', 'seaDist', 'avgElev',
             'sdElev', 'absLat', 'numLang', 'dispSuitable', 'climate',
             'soil', 'sdClimate', 'sdSoil', 'sdSuitable', 'avgSuitable',
             'pop95', 'area', 'lnLang', 'lnPopDens1995', 'migrationDist',
             'lnArea', 'pctIndigenous', 'lnPopDens1500', 'agriTran',
             'americas', 'europe', 'africa', 'asiaPac')
# for (col in modelCols) {
#  data[,col] = standardize(data[,col])
# }
dataStd = data %>% mutate(across(!countryName & !countryCode , standardize))
```

```{r model1.1, echo=F}
model1.1 = lm(lnLang ~ absLat, dataStd)
```

```{r model1.2, echo=F}
model1.2 = lm(lnLang ~ sdElev + sdSuitable + avgElev + avgSuitable + absLat, dataStd)
```

```{r model1.3, echo=F}
model1.3 = lm(lnLang ~ sdElev + sdSuitable + avgElev + avgSuitable + absLat
            + avgPrecip + avgTemp + lnArea + seaDist + migrationDist, dataStd)
```

```{r model1.4, echo=F}
model1.4 = lm(lnLang ~ sdElev + sdSuitable + avgElev + avgSuitable + absLat
            + avgPrecip + avgTemp + lnArea + seaDist + migrationDist + lnPopDens1995
            + africa + europe + americas + asiaPac, dataStd)
```

```{r model1.5, echo=F}
missingData = is.na(dataStd$agriTran) | is.na(dataStd$entryYear) | is.na(dataStd$lnPopDens1500)
for (col in modelCols) {
  dataStd[!missingData, col] = standardize(dataStd[!missingData,col])
}

model1.5 = lm(lnLang ~ sdElev + sdSuitable + avgElev + avgSuitable + absLat
            + avgPrecip + avgTemp + lnArea + seaDist + migrationDist + lnPopDens1995
            + lnPopDens1500 + entryYear + agriTran
            + africa + europe + americas + asiaPac, dataStd, na.action = na.exclude)
```

```{r tbl1, results='hide', echo=F}
models = paste0("model1.", 1:5)
coefs = sapply(models, function(model) {coeftest(get(model),
                                                 vcov = vcovHC(get(model), "HC1"))[, 1]}) %>% 
  unlist() %>% data.frame()
coefs$model = substr(row.names(coefs), 1, 8)
coefs$column = substr(row.names(coefs), 10, nchar(row.names(coefs)))

ses = sapply(models, function(model) {coeftest(get(model),
                                               vcov = vcovHC(get(model), "HC1"))[, 2]}) %>% 
  unlist() %>% data.frame()
ses$model = substr(row.names(ses), 1, 8)
ses$column = substr(row.names(ses), 10, nchar(row.names(ses)))

pvals = sapply(models, function(model) {coeftest(get(model),
                                                 vcov = vcovHC(get(model), "HC1"))[, 4]}) %>% 
  unlist() %>% data.frame()
pvals$model = substr(row.names(pvals), 1, 8)
pvals$column = substr(row.names(pvals), 10, nchar(row.names(pvals)))

order = c('sdElev', 'sdSuitable', 'avgElev', 'avgSuitable', 'absLat', 
          'avgPrecip', 'avgTemp', 'lnArea', 'seaDist', 'migrationDist',
          'lnPopDens1995', 'lnPopDens1500', 'entryYear', 'agriTran')

pvalsPivoted = pvals %>% pivot_wider(names_from = "model", values_from = '.') %>%
  slice(match(order, column))

tbl1 = rbind(coefs %>% pivot_wider(names_from = "model", values_from = '.'),
             ses %>% pivot_wider(names_from = "model", values_from = '.'))
tbl1$stat = c(rep('Estimate', 19), rep('SE', 19))
indices = c(rbind(match(order, tbl1$column), match(order, tbl1$column) + 19))
tbl1 = tbl1 %>% slice(indices)
```

```{r tbl1Print, results='show', echo=F}
tbl1format = data.frame(tbl1)
for (model in models) {
  estimRows = !is.na(tbl1[, model]) & (tbl1$stat == 'Estimate')
  seRows = !is.na(tbl1[, model]) & (tbl1$stat == 'SE')

  tbl1format[estimRows, model] = sprintf(fmt = "%.3f",
                                         tbl1[estimRows, model] %>% unlist() %>% as.numeric())
  tbl1format[seRows, model] = paste0("(", sprintf(fmt = "%.3f",
                                                  tbl1[seRows, model] %>%
                                                    unlist() %>% as.numeric()), ")")
  
  significant = rep(pvalsPivoted[, model] < .01, each = 2)
  significant[is.na(significant)] = FALSE
  tbl1format[estimRows, model] = cell_spec(tbl1format[estimRows, model],
                                           italic = significant[estimRows])
  tbl1format[seRows, model] = cell_spec(tbl1format[seRows, model], italic = significant[seRows])
}

tbl1format$name = c('Variation in elevation', NA, 'Variation in land quality', NA,
                    'Mean elevation', NA, 'Mean land quality', NA,
                    'Absolute latitude', NA, 'Mean precipitation', NA,
                    'Mean temperature', NA, 'Ln(Area)', NA,
                    'Distance from the sea', NA, 'Migratory distance from East Africa', NA,
                    'Ln(Population density in 1995)', NA, 'Ln(Population density in 1500)', NA,
                    'Year of independence', NA, 'Timing of transition to agriculture', NA
                    )

col.names = c("Variable", paste0("(", 1:5, ")"))

tbl1format %>% select(8, 2:6) %>%
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE, linesep = c("", "\\addlinespace"),
             col.names = col.names, align = "r", escape = F,
             caption = "Main specification for the cross-country analysis. Italics indicate significance at the 1\\% level.") %>%
  row_spec(seq(2, 28, 2), font_size = 8)
```

```{r tbl1Info, results='show', echo=F}
tbl1info = data.frame(
  model = 1:5,
  cont = c("No", "No", "No", "No", "Yes"),
  nobs = sapply(models, function(model) { nobs(get(model))}),
  rsq = sapply(models, function(model) {
    formatC(summary(get(model))$r.squared, digits = 2, format = 'f')
    }), row.names = NULL
  )
tbl1info %>% 
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE,
               col.names = c('Model', 'Continental Indicators', 'Observations', '$R^2$'),
               escape = F,
               caption = "Information for each model in cross-country analysis.")
```

The interpretation of these results is much the same as in the original paper. In all four models, variation in elevation and variation in land quality were useful predictors of the log number of languages, as originally hypothesized by the author.
The effects of the geographic variables are also noteworthy. Naturally, the effect of absolute latitude becomes insignificant once precipitation and temperature are introduced, as those two are highly correlated with distance from the equator. Between models 1.1 and 1.2, and also 1.2 and 1.3, the observed $R^2$ makes sizable jumps, indicating that these geographic features are very useful in explaining linguistic diversity. About the distance distance from the sea coefficient, the author has this intriguing interpretation:

> ... areas that are increasingly isolated from the sea have been experiencing limited population mixing and thus should, on average, display higher ethnolinguistic fractionalization. It should be noted, however, that mean distance from the coast also captures the vulnerability of different areas to both the incidence and the intensity of invasion and colonization. Thus, the coefficient should be interpreted cautiously.

As the coefficient was never much more than one standard error above zero anyway, it is easy to ignore this effect entirely.

The final model introduces variables related to a country's history. The log of population density in 1500 does have a significant effect (at larger thresholds), and the author suggests "conditional on geographic characteristics, contemporary ethnic diversity may have been influenced by a country’s historical levels of development." A mechanism that would track with this explanation is that the time of transition to a "modern" nation state, which
necessarily reduces the ethnic diversity of a country, is naturally tied with its historic development level.

<!-- # NOTE: I actually don't agree with the below conclusion - density 1500 is proxy for early transition to "modernity' (Belgium, North Italy etc) which drastically centralized ethnic identities. For example, the majority of France didn't understand "french" until the revolution. 
Added explanation above-->

However, it would also seem plausible that countries that were denser in 1500 would have greater ethnolinguistic diversity today, 
simply due to having more people to split. It could also be that this new feature is simply "stealing" the effect of the 1990 density feature,
as the two are very strongly correlated. Therefore, we consider it questionable that such "historical levels of development" have much effect on modern diversity.

Another thing to note is that we noticed some inaccuracies with the provided years of independence. For example, the United States was listed as 1816, as opposed to 1776 or 1783. Other long-existing countries, such as Portugal and Denmark, were also given this 1816 value. Additionally, former Soviet republics were all (correctly) given a year of 1991, despite many of those having been independent countries with established notions of ethnic identity 
long before being absorbed into the Soviet Union. This further emphasizes that independence year in general is almost arbitrary — 
it would have been surprising if it had a significant relationship with the outcome. 

Finally, the author includes five indicator variables in the last regression that map to the continent the country is located
in. This is done in an attempt to better model both geographic (the author mentions Africa as being less geographically
varying as a whole), as well as continent-wide historic effects.



## Critique of Assumptions


As stated before, this model only requires two main assumptions:

1. The functional form of \ref{eq:model1} is correct.
2. The error terms are independent.

Both assumptions are hard to take fully for granted. Starting with the second, it is likely that there is some spatial correlation between neighboring countries, leading to dependence among the error terms. However, such correlation could have already been sufficiently modeled by including geographic features such as migration distance and average temperature. Additionally, the virtual country analysis, which we will reanalyze in Section \ref{virtual}, shows that the results of the model still hold after abstracting away the established country boundaries.

To informally test the whether or not the linearity assumption holds, Figure \ref{fig:resid1} shows the residual plot for the fifth model. While there is no curved relationship in the plot, it is clear that the residuals tend to increase as the dependent variable increases. This means that there is likely some other feature or combination of features which significantly impacts the log number of languages, which this model does not include.
While we only show the residuals for the fifth model, but given it is the best specified model, it is expected that the
residual plots for the other models would look even worse.

Somewhat coincidentally, the residuals do look roughly homoskedastic, even though that assumption was relaxed. Another diagnostic plot that is commonly used is a Normal Q-Q plot of the residuals, but as this model does not require normality, we will not include such a plot here.

```{r resid1, fig.cap="\\label{fig:resid1} Residual Plot for Model 1.5", echo=F, fig.width = 6.5, fig.height=4}
yhat = model1.5$residuals
y = model1.5$model$lnLang
plot(y, yhat, xlab = "", ylab = "", cex.axis = .75)
title(ylab = "Residuals", xlab = "Ln(Number of Languages)", mgp = c(2, .5, 0), cex.lab = .75)
residModel = lm(yhat ~ y)
abline(0, 0)
lines(y, y * residModel$coefficients['y'], col = 'red', type = 'l')
```

<!-- \newpage  -->

# Robustness Check of Analysis 1

## Table 2A

Table \ref{tab:tbl2aPrint} recreates the first series of robustness check for the model described above. Since the dependent
variable is a count, it makes sense to employ a regression model that models that fact directly. The author argues for the 
*negative binomial* generative model due to the supposed *overdispersion* in the number of languages. The results are
presented in the first column. 

The second robustness check substitutes the measure of variance - standard deviation - of the two most crucial covariates
(elevation and land quality) with a bit more "robust measure" - "dispersion", which the author defines as the range between
the minimum and maximum values.

The third and fourth columns attempt to substitute the variation in land quality with alternative metrics: the means and
variations in climatic and soil suitability, respectively. These are isolated components of the composite land suitability
metric used in the original regression.

All the regressions in this table include the continental fixed effects mentioned previously. 
The regressions with alternative covariates confirm that the variation in land quality (or it's counterpart) is the most
impactful factor in determining ethnolinguistic diversity within a country. Furthermore, our replication finds the published
results to hold exactly.

Table \ref{tab:tbl2aInfo} summarizes the control groups used in the robustness check regressions. Interestingly,
the finding are robust to the substitution of the most important covariates with alternative measures, since the $R^2$ 
coefficient matches that of the last regression in the original analysis, and is completely stable across all comparable
models using alternative covariates.



```{r model1.1Rob, results='hide', echo=F, eval=T}
robust1.1 <- glm.nb(numLang ~ absLat + sdSuitable + sdElev + avgElev + avgSuitable + avgPrecip +
                    avgTemp + lnArea + seaDist + migrationDist + lnPopDens1995 + lnPopDens1500 +
                    entryYear + agriTran + africa + europe + americas + asiaPac
                    , data, na.action = na.exclude)
```

```{r model1.1RobTable, results='show', echo=F, eval=F}
summary(robust1.1)
```

```{r model1.2Rob, results='hide', echo=F, eval=T}
robust1.2 <- lm(lnLang ~ absLat + dispElev + dispSuitable + avgElev + avgSuitable + avgPrecip +
                avgTemp +  lnArea +  seaDist + migrationDist +  lnPopDens1995 + lnPopDens1500 +
                entryYear + agriTran + africa + europe + americas + asiaPac,
                data, na.action = na.exclude)
                    
```

```{r model1.2RobTable, results='show', echo=F, eval=F}
summary(robust1.2)
```

```{r model1.3Rob, results='hide', echo=F, eval=T}
robust1.3 <- lm(lnLang ~ absLat + sdElev + sdClimate + avgElev + climate + avgPrecip +  avgTemp +  
                lnArea +  seaDist + migrationDist +  lnPopDens1995 +  lnPopDens1500 + entryYear +
                agriTran + africa + europe + americas + asiaPac,
                data, na.action = na.exclude)
                    
```

```{r model1.3RobTable, results='show', echo=F, eval=F}
summary(robust1.3)
```


```{r model1.4Rob, results='hide', echo=F, eval=T}
# NOTE: the conditional doesn't remove anything from the `data` df
data1.4 <- data[(data$suitableCells > 9) & (data$lnArea > -10), ]

robust1.4 <- lm(lnLang ~ absLat + sdElev + sdSoil + avgElev + soil + avgPrecip +  avgTemp +  
                lnArea +  seaDist + migrationDist +  lnPopDens1995 +  lnPopDens1500 + entryYear +
                agriTran + africa + europe + americas + asiaPac,
                data1.4, na.action = na.exclude)
                    
```

```{r model1.4RobTable, results='show', echo=F, eval=F}
summary(robust1.4)
```

```{r tbl2a, results='hide', echo=F}
models <- paste0("robust1.", 1:4)
coeffs <- lapply(models, function(model) {coeftest(get(model),
                                                   vcov = vcovHC(get(model), "HC1"))[, 1]})
names(coeffs) <- models

vars <- unique(unlist(lapply(coeffs, names)))

coeffDf <- data.frame(row.names = vars)
for(model in models) coeffDf[names(coeffs[[model]]), model] <- coeffs[[model]]

ses <- lapply(models, function(model) {coeftest(get(model), vcov = vcovHC(get(model),
                                                                          "HC1"))[, 2]})
names(ses) <- models
sesDf <- data.frame(row.names = vars)
for(model in models) sesDf[names(ses[[model]]), model] <- ses[[model]]

pvals <- lapply(models, function(model) {coeftest(get(model), vcov = vcovHC(get(model),
                                                                            "HC1"))[, 4]})
names(pvals) <- models
pvalsDf <- data.frame(row.names = vars)
for(model in models) pvalsDf[names(pvals[[model]]), model] <- pvals[[model]]

order <-c('sdElev', 'sdSuitable', 'dispElev', 'dispSuitable', 'sdClimate',
          'climate', 'sdSoil', 'soil')

coeffDf <- coeffDf[order, ]
sesDf   <- sesDf[order, ]
pvalsDf <- pvalsDf[order, ]

# interleave rows
coeffDf[, "stat"] <- "Estimate"
sesDf[, "stat"] <- "SE"
tbl2a <- gdata::interleave(coeffDf, sesDf)
```

```{r tbl2aPrint, results='show', echo=F}
# ensure a hard copy
tbl2aformat <- data.frame(tbl2a)

for (model in models) {
  estimRows <- !is.na(tbl2aformat[, model]) & (tbl2aformat$stat == 'Estimate')
  seRows <- !is.na(tbl2aformat[, model]) & (tbl2aformat$stat == 'SE')

  tbl2aformat[estimRows, model] <- sprintf(fmt = "%.3f", tbl2aformat[estimRows, model]
                                           %>% unlist() %>% as.numeric())
  tbl2aformat[seRows, model] <- paste0("(", sprintf(fmt = "%.3f", tbl2aformat[seRows, model]
                                             %>% unlist() 
                                             %>% as.numeric()), ")")
  
  significant <- rep(pvalsDf[, model] < .01, each = 2)
  significant[is.na(significant)] <- FALSE
  
  tbl2aformat[estimRows, model] <- cell_spec(tbl2aformat[estimRows, model],
                                             italic = significant[estimRows])
  tbl2aformat[seRows, model] <- cell_spec(tbl2aformat[seRows, model],
                                          italic = significant[seRows])
}

tbl2aformat$name <- c('Variation in elevation', NA, 'Variation in land quality', NA,
                    'Dispersion of elevation', NA, 'Dispersion of land quality', NA,
                    'Variation in climatic suitability', NA, 'Mean climatic suitability', NA,
                    'Variation in soil suitability', NA, 'Mean soil suitability', NA)

col.names <- c("Variable", "Negative binomial", "OLS1", "OLS2", "OLS3")

tbl2aformat %>% 
  select(name, 1:4, -stat) %>%
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE, linesep = c("", "\\addlinespace"),
             col.names = col.names, 
             row.names = F,
             align = "r", escape = F,
             caption = "Table 2A—Robustness Checks for the Cross-Country Analysis. Italics indicate significance at the 1\\% level.")  %>%
  row_spec(seq(2, nrow(tbl2aformat), 2), font_size = 8)

```

```{r tbl2aInfo, results='show', echo=F, eval=T}
tbl2ainfo <-  data.frame(
  model = 1:4,
  cont = c("Yes", "Yes", "Yes", "Yes"),
  nobs = sapply(models, function(model) { nobs(get(model))}),
  rsq = c("-", lapply(models[-1], function(model) {
    formatC(
      summary(get(model))$r.squared
      , digits = 2, format = 'f')
    })) %>% unlist,
  loglik = c(formatC(robust1.1$twologlik / 2, digits = 2, format = 'f'), rep("-", 3)),
  row.names = NULL
  )

tbl2ainfo %>% 
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE,
               col.names = c('Model', 'Continental Indicators', 'Observations', '$R^2$',
                             "Log pseudolikelihood"),
               escape = F,
               caption = "Information for each model in Table 2A: cross-country robustness check")
```



## Table 2B

```{r data_import2b, echo=F, eval=T}
data2b <- read.dta13("data_raw/Table_3b.dta")

standardized <- list("lpd1500", "yrentry", "agritran", "elf", "elf3", "elf5", "elf7", "elf9",
                     "abs_lat", "sd_climsuit", "sd_emean", "emean", "mean_climsuit", "precav",
                     "tempav", "lnareakm2", "distc", "migdist", "lnpop95", "americas", "reg_eap",
                     "africa", "europe", "nmbr_climsuit")

notStdized <- names(data2b)[! names(data2b) %in%  standardized]
data2bStd <- data2b %>% mutate(across(! all_of(notStdized) , standardize))

```

Table \ref{tab:tbl2bPrint} introduces a new dependent variable in place of the (logarithm) of the languages spoken -
*ELF - Etnolinguistic fractionalization*. This is the probability that two randomly drawn individuals would belong to
different enthnolinguistic groups and is taken from an updated version of an old Soviet work - *Atlas Narodov
Mira* (Atlas of the World's Nations) in the first three columns. Additionally, climatic data is again used in lieu of 
the land suitability metric used in the initial model.

Of note here is that, absent a continental fixed-effect variable, the variation in elevation coefficient actually flips 
its sign while becoming insignificant, while the situation is again reversed once the fixed effect is introduced. This
seems to track with the author's explanation that Africa, for example, is less varying in elevation in general, so the 
numerical effect of the latter needs to be adjusted per-continent.

In columns 4-7, the same metric is reconstructed from the *Ethnologue* dataset using increasing fineness in defining 
ethnolinguistic groups via the aggregation of language trees. Despite the introduction of additional geographic features,
the variations in elevation and land quality remain highly significant. Additionally, fractionalization is found to be
positively impacted by the average amount of precipitation a country receives and its distance from the coast, while
latitude and migratory distance from East Africa impact it negatively.

The replication again obtains complete agreement in the values, confidence intervals, and the $R^2$ coefficient with the 
published results. The noticeably small values of $R^2$ across the models perhaps indicate faults with the dependent variable;
for the latter columns, this is a largely arbitrary level of aggregation in clustering trees, so it's unsurprising the agreement
represented by $R^2$ even decreases in comparison to the third column using the "original" ELF.




```{r model1.2.1, results='hide', echo=F, eval=T}
robust1.2.1 <- lm(elf ~ abs_lat, data2bStd, na.action = na.exclude)

```

```{r model1.2.1Table, results='show', echo=F, eval=F}
summary(robust1.2.1)
```


```{r model1.2.2, results='hide', echo=F, eval=T}
robust1.2.2 <- lm(elf ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit,
                  data2bStd, na.action = na.exclude)

```

```{r model1.2.2Table, results='show', echo=F, eval=F}
summary(robust1.2.2)
```


```{r model1.2.3, results='hide', echo=F, eval=T}
robust1.2.3 <- lm(elf ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit + 
                  precav + tempav + lnareakm2 + distc + migdist + lnpop95 + lpd1500 + yrentry +
                  agritran + africa + europe + americas + reg_eap
                  , data2bStd, na.action = na.exclude)

```

```{r model1.2.3Table, results='show', echo=F, eval=F}
summary(robust1.2.3)
```

```{r model1.2.4, results='hide', echo=F, eval=T}
robust1.2.4 <- lm(elf3 ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit + 
                  precav + tempav + lnareakm2 + distc + migdist + lnpop95 + lpd1500 + yrentry +
                  agritran + africa + europe + americas + reg_eap
                  , data2bStd, na.action = na.exclude)

```

```{r model1.2.4Table, results='show', echo=F, eval=F}
summary(robust1.2.4)
```

```{r model1.2.5, results='hide', echo=F, eval=T}
robust1.2.5 <- lm(elf5 ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit + 
                  precav + tempav + lnareakm2 + distc + migdist + lnpop95 + lpd1500 + yrentry +
                  agritran + africa + europe + americas + reg_eap
                  , data2bStd, na.action = na.exclude)

```

```{r model1.2.5Table, results='show', echo=F, eval=F}
summary(robust1.2.5)
```

```{r model1.2.6, results='hide', echo=F, eval=T}
robust1.2.6 <- lm(elf7 ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit + 
                  precav + tempav + lnareakm2 + distc + migdist + lnpop95 + lpd1500 + yrentry +
                  agritran + africa + europe + americas + reg_eap
                  , data2bStd, na.action = na.exclude)

```

```{r model1.2.6Table, results='show', echo=F, eval=F}
summary(robust1.2.6)
```

```{r model1.2.7, results='hide', echo=F, eval=T}
robust1.2.7 <- lm(elf9 ~ abs_lat + sd_emean + sd_climsuit + emean + mean_climsuit + 
                  precav + tempav + lnareakm2 + distc + migdist + lnpop95 + lpd1500 + yrentry +
                  agritran + africa + europe + americas + reg_eap
                  , data2bStd, na.action = na.exclude)

```

```{r model1.2.Table, results='show', echo=F, eval=F}
summary(robust1.2.7)
```

```{r tbl2b, results='hide', echo=F, eval=T}
models <- paste0("robust1.2.", 1:7)
coeffs <- lapply(models, function(model) {coeftest(get(model), vcov = vcovHC(get(model),
                                                                             "HC1"))[, 1]})
names(coeffs) <- models

vars <- unique(unlist(lapply(coeffs, names)))

coeffDf <- data.frame(row.names = vars)
for(model in models) coeffDf[names(coeffs[[model]]), model] <- coeffs[[model]]

ses <- lapply(models, function(model) {coeftest(get(model), vcov = vcovHC(get(model),
                                                                          "HC1"))[, 2]})
names(ses) <- models
sesDf <- data.frame(row.names = vars)
for(model in models) sesDf[names(ses[[model]]), model] <- ses[[model]]

pvals <- lapply(models, function(model) {coeftest(get(model), vcov = vcovHC(get(model),
                                                                            "HC1"))[, 4]})
names(pvals) <- models
pvalsDf <- data.frame(row.names = vars)
for(model in models) pvalsDf[names(pvals[[model]]), model] <- pvals[[model]]

order <-c('sd_emean', 'sd_climsuit', 'emean', 'mean_climsuit', 'abs_lat',
          'precav', 'tempav', 'lnareakm2', 'distc', 'migdist', 'lnpop95', 'lpd1500',
          'yrentry', 'agritran')

coeffDf <- coeffDf[order, ]
sesDf   <- sesDf[order, ]
pvalsDf <- pvalsDf[order, ]

# interleave rows
coeffDf[, "stat"] <- "Estimate"
sesDf[, "stat"] <- "SE"
tbl2b <- gdata::interleave(coeffDf, sesDf)
```

```{r tbl2bPrint, results='show', echo=F, eval=T}
# ensure a hard copy
tbl2bformat <- data.frame(tbl2b)

for (model in models) {
  estimRows <- !is.na(tbl2bformat[, model]) & (tbl2bformat$stat == 'Estimate')
  seRows <- !is.na(tbl2bformat[, model]) & (tbl2bformat$stat == 'SE')

  tbl2bformat[estimRows, model] <- sprintf(fmt = "%.3f", tbl2bformat[estimRows, model]
                                           %>% unlist() %>% as.numeric())
  tbl2bformat[seRows, model] <- paste0("(", sprintf(fmt = "%.3f", tbl2bformat[seRows, model]
                                             %>% unlist() 
                                             %>% as.numeric()), ")")
  
  significant <- rep(pvalsDf[, model] < .01, each = 2)
  significant[is.na(significant)] <- FALSE
  
  tbl2bformat[estimRows, model] <- cell_spec(tbl2bformat[estimRows, model],
                                             italic = significant[estimRows])
  tbl2bformat[seRows, model] <- cell_spec(tbl2bformat[seRows, model],
                                          italic = significant[seRows])
}

tbl2bformat$name <- c('Variation in elevation', NA, 'Variation in climatic suitability', NA,
                    'Mean elevation', NA, 'Mean climatic suitability', NA,
                    'Absolute latitude', NA, 'Mean precipitation', NA,
                    'Mean temperature', NA, 'Ln(area)', NA,
                    'Distance from the sea', NA, 'Migratory distance from East Africa', NA,
                    'Ln(Population density in 1995)', NA, 'Ln(Population density in 1500)', NA,
                    'Year of independence', NA, 'Timing of transition to agriculture', NA
                    )

col.names <- c("Variable", paste0("(", 1:7, ")"))

tbl2bformat %>% 
  select(name, 1:7, -stat) %>%
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE, linesep = c("", "\\addlinespace"),
             col.names = col.names, 
             row.names = F,
             align = "r", escape = F,
             caption = "Table 2B—Linguistic Fractionalization across Countries. Italics indicate significance at the 1\\% level.")  %>%
  row_spec(seq(2, nrow(tbl2bformat), 2), font_size = 8)

```

```{r tbl2bInfo, results='show', echo=F, eval=T}
tbl2binfo <-  data.frame(
  model = 1:7,
  cont = c(rep("No", 2), rep("Yes", 5)),
  nobs = sapply(models, function(model) { nobs(get(model))}),
  rsq = sapply(models, function(model) {
    formatC(summary(get(model))$r.squared, digits = 2, format = 'f')
    }),
  row.names = NULL
  )

tbl2binfo %>% 
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE,
               col.names = c('Model', 'Continental Indicators', 'Observations', '$R^2$'),
               escape = F,
               row.names = F,
               caption = "Information for each model in Table 2B: Linguistic Fractionalization across Countries")
```

<!-- \newpage -->

# Analysis 2: Virtual Country (Re-Analysis)  \label{virtual}

The second analysis Michalopolous presents in his paper is essentially a repeat of the the first, but instead aggregating geographic and ethnic information over "virtual" countries as opposed to real ones. The stated motivation for this is "to investigate whether the relationship between geography and ethnic diversity holds true at an arbitrary level of aggregation."

As with the previous analysis, the geographic features are derived from a dataset of cells, each of size .5-by.5 decimal degrees. However, instead of aggregating these cells at the country level as before, we now split up the world into blocks of size 2.5-by-2.5 decimal degrees, with each block containing 25 cells. Each block is precisely a "*virtual country.*"

To obtain the number of languages in each virtual country, Michalopolous simply intersected the shapefile provided in the World Language Mapping System with the newly-formed grid. However, probably due to the proprietary nature of the WLMS, the "number of languages" variable was withheld from the public data download, meaning we could not exactly replicate the analysis.

Fortunately, we stumbled across the *Geo-referencing of Ethnic Groups* (GREG) dataset [@weidmann_representing_2010], which contains a shapefile of the locations of 928 ethnic groups across the world. As Michalopolous was only using linguistic diversity as a proxy for ethnic diversity, we decided it would be useful to model ethnic diversity directly, to see if the original paper's results held up with the GREG data.

## Data Cleaning

The original GREG dataset required some manipulation to get it in a format suitable to swap in for the WLMS. Each polygon 
was labeled with up to three ethnic groups, so we had to melt and then dissolve the polygons such that each polygon represented only one ethnic group, and each ethnic group was only assigned to one polygon. For details, see the appendix which shows the geoprocessing steps performed with the `geopandas` module in Python.

In the original paper, Michalopolous described the steps he took to filter the virtual countries on criteria mostly based on the amount of "coverage" each country had in the WLMS data. If a large portion of a virtual country was an area which contained no languages—for example, the Sahara Desert—that virtual country was excluded from the analysis. The public data download, which contained the virtual countries after this filter had been applied, contained 1,888 virtual countries. Due to differences in coverage between WLMS and GREG, applying the same criteria to GREG would have resulted in 2,476 countries. Including these additional countries would have required obtaining the other features for these areas, and as Michalopolous did not document this procedure well, we decided that this was not feasible. The end result was that our dataset only included the intersection of the sets derived WLMS and GREG, which excluded the ~600 countries from the dataset derived from GREG, but also about 30 countries that had enough coverage in WLMS, but did not in GREG.

Finally, the actual regressions performed in the paper used a dataset that was further filtered down. That is, there must have been at least 3000 people living in the virtual country in 1995, and at least 10 of the 25 cells that comprise a virtual country had to have been completely covered by the WLMS dataset. We applied both of these criteria here as well when reproducing the regressions.

## Replication

The model specification for this analysis is almost exactly the same as before, except now each unit $i$ is a virtual country, and "numLang" is really the number of  ethnic groups:

\begin{equation} \label{eq:model2}
\ln\left(\text{numLang}_i\right) = \beta_0 + \beta_1*\text{absLat}_i + \beta_2*\text{sdElev}_i + \beta_3*\text{sdSuitable}_i + \beta_4* X_i + \epsilon_i
\end{equation}

Additionally, regressions 2.5, 2.6, and 2.7 (the second number corresponds to the columns in Table \ref{tab:tbl4Print}) 
are performed only on virtual countries meeting a certain criterion. Regression 2.5 looks only at virtual countries located in the tropics,
2.6 looks at countries not located in the tropics, and 2.7 filters to virtual countries that are located entirely within a real country.

```{r dataImport2, echo=F}
data2 = read.dta13('data_raw/Tables4-7b.dta')
greg = read.csv('greg.csv')
colnames(greg) = c('uniq_cnt25', 'number_suit_valid25', 'nmbrlang')

data2 = data2 %>% select(-c('nmbrlang', 'number_suit_valid25')) %>% merge(greg, by = 'uniq_cnt25')

data2$lnnmbrlang = log(data2$nmbrlang)
```

```{r rename2, echo=F}
colnames(data2) = c('virtCode', 'countryCode', 'climate', 'soil',
                   'sdClimate', 'sdSoil', 'seaDist', 'avgElev', 'avgPrecip',
                   'avgTemp', 'sdElev', 'waterArea', 'avgSuitable',
                   'sdSuitable', 'popDens95', 'dispSuitable', 'area', 'withinCountry', 
                   'numCountry', 'migrationDist', 'lnLang', 'totalPop95',
                   'absLat', 'tropics', 'dispElev', 'lnArea', 
                   'lnPopDens95', 'pctIndigenous', 'diffAvgElev',
                   'diffAvgPrecip', 'diffAvgTemp', 'diffAvgSuit',
                   'overlap', 'suitableCells', 'numLang')

modelCols = c('lnLang', 'sdElev', 'sdSuitable', 'avgElev', 'avgSuitable',
              'absLat', 'avgPrecip', 'avgTemp', 'lnArea', 'seaDist', 'waterArea',
              'withinCountry', 'numCountry', 'migrationDist', 'lnPopDens95')
```


```{r model2.1, echo=F}
condition = (data2$totalPop95 >= 3000) & (data2$suitableCells >= 10)
for (col in modelCols) {
  data2[condition, paste0(col, '1')] = standardize(data2[condition, col])
}
model2.1 = lm(lnLang1 ~ absLat1, data2 %>% filter(condition))
coefs = coeftest(model2.1, vcov = vcovCL, cluster = ~countryCode)[, 1]
ses = coeftest(model2.1, vcov = vcovCL, cluster = ~countryCode)[, 2]
pvals = coeftest(model2.1, vcov = vcovCL, cluster = ~countryCode)[, 4]
```

```{r model2.2, echo=F}
model2.2 = lm(lnLang1 ~ sdElev1 + sdSuitable1 + avgElev1 + avgSuitable1 + absLat1,
            data2 %>% filter(condition))
coefs = c(coefs, coeftest(model2.2, vcov = vcovCL, cluster = ~countryCode)[, 1])
ses = c(ses, coeftest(model2.2, vcov = vcovCL, cluster = ~countryCode)[, 2])
pvals = c(pvals, coeftest(model2.2, vcov = vcovCL, cluster = ~countryCode)[, 4])
```

```{r model2.3, echo=F}
model2.3 = lm(lnLang1 ~ sdElev1 + sdSuitable1 + avgElev1 + avgSuitable1 + absLat1
            + avgPrecip1 + avgTemp1 + lnArea1 + seaDist1 + waterArea1
            + withinCountry1 + numCountry1 + migrationDist1,
            data2 %>% filter(condition))
coefs = c(coefs, coeftest(model2.3, vcov = vcovCL, cluster = ~countryCode)[, 1])
ses = c(ses, coeftest(model2.3, vcov = vcovCL, cluster = ~countryCode)[, 2])
pvals = c(pvals, coeftest(model2.3, vcov = vcovCL, cluster = ~countryCode)[, 4])
```


```{r model2.4, echo=F}
model2.4 = lm_robust(lnLang1 ~ sdElev1 + sdSuitable1 + avgElev1 + avgSuitable1 + absLat1
            + avgPrecip1 + avgTemp1 + lnArea1 + seaDist1 + waterArea1
            + withinCountry1 + numCountry1 + migrationDist1 + lnPopDens951,
            data2 %>% filter(condition),
            fixed_effects = ~countryCode, se_type = "stata")
coefs = c(coefs, 0, model2.4$coefficients)
ses = c(ses, 0, model2.4$std.error)
pvals = c(pvals, 0, model2.4$p.value)
```

```{r model2.5, echo=F}
condition = (data2$totalPop95 >= 3000) & (data2$suitableCells >= 10) & (data2$tropics == 1)
for (col in modelCols) {
  data2[condition, paste0(col, '5')] = standardize(data2[condition, col])
}
model2.5 = lm_robust(lnLang5 ~ sdElev5 + sdSuitable5 + avgElev5 + avgSuitable5 + absLat5
            + avgPrecip5 + avgTemp5 + lnArea5 + seaDist5 + waterArea5
            + withinCountry5 + numCountry5 + migrationDist5 + lnPopDens955,
            data2 %>% filter(condition),
            fixed_effects = ~countryCode, se_type = "stata")
coefs = c(coefs, 0, model2.5$coefficients)
ses = c(ses, 0, model2.5$std.error)
pvals = c(pvals, 0, model2.5$p.value)
```

```{r model2.6, echo=F}
condition = (data2$totalPop95 >= 3000) & (data2$suitableCells >= 10) & (data2$tropics == 0)
for (col in modelCols) {
  data2[condition, paste0(col, '6')] = standardize(data2[condition, col])
}
model2.6 = lm_robust(lnLang6 ~ sdElev6 + sdSuitable6 + avgElev6 + avgSuitable6 + absLat6
            + avgPrecip6 + avgTemp6 + lnArea6 + seaDist6 + waterArea6
            + withinCountry6 + numCountry6 + migrationDist6 + lnPopDens956,
            data2 %>% filter(condition),
            fixed_effects = ~countryCode, se_type = "stata")
coefs = c(coefs, 0, model2.6$coefficients)
ses = c(ses, 0, model2.6$std.error)
pvals = c(pvals, 0, model2.6$p.value)
```

```{r model2.7, echo=F}
condition = (data2$totalPop95 >= 3000) & (data2$suitableCells >= 10) & (data2$withinCountry == 1)
for (col in modelCols) {
  data2[condition, paste0(col, '7')] = standardize(data2[condition, col])
}
model2.7 = lm_robust(lnLang7 ~ sdElev7 + sdSuitable7 + avgElev7 + avgSuitable7 + absLat7
            + avgPrecip7 + avgTemp7 + lnArea7 + seaDist7 + waterArea7
            + migrationDist7 + lnPopDens957,
            data2 %>% filter(condition),
            fixed_effects = ~countryCode, se_type = "stata")
coefs = c(coefs, 0, model2.7$coefficients)
ses = c(ses, 0, model2.7$std.error)
pvals = c(pvals, 0, model2.7$p.value)
```


```{r tbl4, results='hide', echo=F}
models = paste0("model2.", 1:7)

names(coefs)[names(coefs) == ""] = "(Intercept)"
coefs = data.frame(coefs, row.names = paste0("model2.",
                                             cumsum(names(coefs) %in% c("(Intercept)", "")),
                                             ".", names(coefs)))
coefs$model = substr(row.names(coefs), 1, 8)
coefs$column = substr(row.names(coefs), 10, nchar(row.names(coefs)) - 1)

names(ses)[names(ses) == ""] = "(Intercept)"
ses = data.frame(ses, row.names = paste0("model2.",
                                         cumsum(names(ses) %in% c("(Intercept)", "")),
                                         ".", names(ses)))
ses$model = substr(row.names(ses), 1, 8)
ses$column = substr(row.names(ses), 10, nchar(row.names(ses)) - 1)

names(pvals)[names(pvals) == ""] = "(Intercept)"
pvals = data.frame(pvals, row.names = paste0("model2.",
                                             cumsum(names(pvals) %in% c("(Intercept)", "")),
                                             ".", names(pvals)))
pvals$model = substr(row.names(pvals), 1, 8)
pvals$column = substr(row.names(pvals), 10, nchar(row.names(pvals)) - 1)

order = c('sdElev', 'sdSuitable', 'avgElev', 'avgSuitable', 'absLat',
          'avgPrecip', 'avgTemp', 'lnArea', 'seaDist', 'waterArea',
          'withinCountry', 'numCountry', 'migrationDist', 'lnPopDens95')

pvalsPivoted = pvals %>% pivot_wider(names_from = "model", values_from = 'pvals') %>% 
  slice(match(order, column))

tbl4 = rbind(coefs %>% pivot_wider(names_from = "model", values_from = 'coefs'), 
             ses %>% pivot_wider(names_from = "model", values_from = 'ses'))
tbl4$stat = c(rep('Estimate', 15), rep('SE', 15))
indices = c(rbind(match(order, tbl4$column), match(order, tbl4$column) + 15))
tbl4 = tbl4 %>% slice(indices)
```

```{r tbl4Print, results='show', echo=F}
tbl4format = data.frame(tbl4)
for (model in models) {
  estimRows = !is.na(tbl4[, model]) & (tbl4$stat == 'Estimate')
  seRows = !is.na(tbl4[, model]) & (tbl4$stat == 'SE')

  tbl4format[estimRows, model] = sprintf(fmt = "%.3f", tbl4[estimRows, model] %>%
                                           unlist() %>% as.numeric())
  tbl4format[seRows, model] = paste0("(", sprintf(fmt = "%.3f", tbl4[seRows, model] %>%
                                                    unlist() %>% as.numeric()), ")")
  
  significant = rep(pvalsPivoted[, model] < .01, each = 2)
  significant[is.na(significant)] = FALSE
  tbl4format[estimRows, model] = cell_spec(tbl4format[estimRows, model],
                                           italic = significant[estimRows])
  tbl4format[seRows, model] = cell_spec(tbl4format[seRows, model], italic = significant[seRows])
}

tbl4format$name = c('Variation in elevation', NA, 'Variation in land quality', NA,
                           'Mean elevation', NA, 'Mean land quality', NA,
                           'Absolute latitude', NA, 'Mean precipitation', NA,
                           'Mean temperature', NA, 'Ln(Area)', NA,
                           'Distance from the sea', NA, 'Water area', NA,
                         'Within-country indicator', NA, 'Number of countries', NA,
                         'Migratory distance from Ethiopia', NA, 'Ln(Population density in 1995)',
                    NA)

col.names = c("Variable", paste0("(", 1:7, ")"))

tbl4format %>% select(10, 2:8) %>%
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE, linesep = c("", "\\addlinespace"),
             col.names = col.names, align = "r", escape = F,
             caption = "Main specification for the virtual country analysis. Italics indicate significance at the 1\\% level.") %>%
  row_spec(seq(2, 28, 2), font_size = 8)
```


```{r tbl4Info, results='show', echo=F}
tbl4info = data.frame(
  model = 1:7,
  cont = c("No", "No", "No", "Yes", "Yes", "Yes", "Yes"),
  nobs = sapply(models, function(model) { nobs(get(model))}),
  rsqOG = formatC(c(.31, .36, .53, .70, .73, .56, .66), digits = 2, format = 'f'),
  rsq = sapply(models, function(model) {
    formatC(summary(get(model))$r.squared, digits = 2, format = 'f')
    }), 
  row.names = NULL
  )
tbl4info %>% 
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE,
               linesep = c(""), align = 'r',
               col.names = c('Model', 'Country Indicators',
                             'Observations', 'WLMS $R^2$', 'GREG $R^2$'),
               escape = F,
               caption = "Information for each model in virtual country analysis.")
```

Table \ref{tab:tbl4Print} shows the results of regressing the log of number of ethnic groups on different sets of features, reproducing Table 4 of the original paper. Note that the features here are very similar to the ones used in the cross-country analysis. The only differences are that features directly relating to real countries, such as independence year, have been swapped for features describing the position of the virtual country in relation to real countries. Table \ref{tab:tbl4Info} shows information about each model, including the observed $R^2$ in the original WLMS regression, and our GREG regression.

Here, the reported standard errors are cluster-robust, with the clusters defined by the real country in which the centroid of each virtual country falls. Whether Stata applies any corrections by default is unclear, but the base formula should be the same as the one described in Section 24.4.1 of Peng Ding's lecture notes [@ding_linear_2022], which we implemented in R using the `sandwich` and `lmtest` packages. Michalopolous did not justify his decision to cluster by real country, and the reader would not know that he did so without checking the footnotes or his code. However, it seems a reasonable decision, considering that virtual countries within the same real country are certainly related beyond any similarities in their features.

Additionally, models 2.4 through 2.7 include a fixed effect for each country. Again, exactly how to replicate the Stata code was not obvious, but the `lm_robust` function from the `estimatr` package appeared to work. This technique essentially just includes one indicator variable for each real country in the model, and then ignores the estimates for those variables in the output. Per Michalopolous:

> Such inclusion of powerful controls, not possible in a cross-country framework, allows me to explicitly take into account any systematic elements related to the nation-building process of current states and thus produce reliable estimates of the effect of geographic heterogeneity on ethnic diversity.

## Comparison

One major difference between GREG and WLMS is that the footprint of each unique ethnic group in GREG are larger than that for each unique language in the WLMS. This makes sense, considering that GREG only contains about 900 entries, yet there are a few thousand unique languages in the WLMS. As a result, the dependent variable is generally a lot smaller in our replication compared to that in the original paper. Michalopolous reports the median number of languages per virtual country as 3, yet here, more than half of the virtual countries contain only one ethnic group. A possible solution to adjust for this would be to simply reduce the size of the virtual countries, but this was infeasible due to our inability to recalculate the rest of the features.

As for the actual results, the first noticeable difference is that in the $R^2$ coefficients. In all models, the $R^2$ is considerably lower in our replication compared to the original, although the differences are smaller for the models including country fixed effects. For example, absolute latitude on its own explains just 4% of the variation in log number of ethnic groups, compared to 31% in the original. However, the coefficient is still significant at the 1% level
and has a negative sign, as it does in the original.

Beyond the worse fits overall, the inference around the coefficients does not differ much between the two models. If a variable is significant at the 1% level in one model, there is a good chance it is significant at at least the 5% or 10% level in its counterpart, or vice versa. Variation in elevation and variation in land quality continue to have a large relationship with the outcome, leading further evidence to the author's original hypothesis. The number of real countries intersected by a virtual country is also a really strong predictor in both sets of models. Michalopolous ponders that this "may be suggestive of the effect of state formation on ethnic diversity and/or an artifact of modern states having drawn political borders along ethnic boundaries." This certainly seems reasonable, but given how diminished the effects of some of the other variables are in our replication, it is surprising that this one is still so large. Perhaps this is another artifact of the aforementioned reduced granularity of GREG compared to WLMS: ethnic groups are even more strongly correlated with national boundaries than languages are.

However, there are a few noteworthy inconsistencies. One is that distance from the sea is significant for every model here, but only for model 2.5 (tropical locations) in the original. Another oddity of the tropical model is that the sign for variation in elevation flips to negative, and log of population density becomes a strong predictor. One reason for this could be differences in how virtual countries in tropical areas were filtered in the GREG dataset compared to WLMS.
A real world explanation is that the densely-populated regions in the tropics are usually found at higher altitudes (e.g., in 
Kenya), where some of the downsides of the climate (such as malaria, etc.) are mitigated. Since densely populated, urban 
areas usually correspond to a lesser number of separate ethnic groups, the sign of the coefficient is less surprising: for there
to be a variation in elevation, one needs to have some elevation in the region in the first place.
<!-- NOTE: this is quite well studied, so it's not that surprising. If you have a high degree of urbanization in the tropics - i.e. high pop density -->
<!-- it's gonna be at higher altitudes. This holds for Africa and south america (cf Bolivia) -->


<!-- \newpage -->


# Robustness Check for Analysis 2

## Robustness Check 1

Table \ref{tab:tbl5aPrint} shows the first series of robustness checks for our second model. The starting point for all 
is regression 2.4 in the previous section; only the usual two most decisive covariates are shown however (as in the original
work). 

The first regression is, similarly as in the first model, a negative binomial. To obtain the cluster-robust standard error,
we use the `geem` routing from the eponymous package. The clusters are again defined to be real-world countries in
which the centroid of each virtual country falls. However, the routine does not include an optimization subroutine for 
the dispersion parameter. Thus, the negative binomial regression is first performed with the usual `glm` call to obtain
the MLE for the dispersion parameter, which is then plugged into the `geem` call as a given.

The second and third are robust OLS (`lm_robust` from `estimatr`) regressions against the log of the number of ethnic groups 
in the country. The variation here is that the second one includes all virtual countries irrespective of their population
(the original filtered them by having at least 3000 inhabitants), while the third ups that threshold to 50000 inhabitants.

The original paper also included two additional regressions, which filtered the original dependent variable - the number
of speakers - by size. Since we don't have that data and are using a substitute variable - the number of ethnic groups - 
we were unable to replicate those two regressions. All the regressions included the per-country fixed-effect variables.

The results show a very good match in terms of both the significance and magnitude of the two variables under consideration
for the two ordinary least squares regressions, while the negative binomial one is less able to reproduce the significance
obtained from using the WLMS dataset. The $R^2$ coefficients (c.f. Table \ref{tab:tbl5aInfo}) are, 
while again lower than in the original, still reasonably high. The higher likelihood of the negative binomial when compared
to the original is likely mostly due to the lesser number of observations, and should not be taken as very authoritative.

Nonetheless, the robustness checks on an alternative dataset seem to confirm the strong relationship these two 
explanatory variables have with ethnolinguistic diversity.

```{r model2.1.1Rob, results='hide', echo=F, eval=T}
# NOTE: Need glm for the theta, and geem for the robust se
robust2.1.1glm <-  glm.nb(numLang ~ absLat + sdElev + sdSuitable +  avgElev + avgSuitable +
                          avgPrecip +  avgTemp +  lnArea +  seaDist + 
                       waterArea +  withinCountry +  numCountry + migrationDist + lnPopDens95
                       + factor(countryCode),
                       data2 %>% filter((data2$suitableCells >= 10) & (data2$totalPop95 >= 3000)),
                       na.action = na.exclude)

robust2.1.1 <- geem(formula = numLang ~ absLat + sdElev + sdSuitable +  avgElev + avgSuitable +
                              avgPrecip +avgTemp +  lnArea +  seaDist + waterArea +
                              withinCountry +  numCountry + migrationDist + lnPopDens95,
                        id = countryCode,
                        nodummy = TRUE,
                        data = data2 %>% filter((data2$suitableCells >= 10) &
                                                  (data2$totalPop95 >= 3000)),
                        family = MASS::negative.binomial(theta = robust2.1.1glm$theta,
                                                         link = 'log'),
                        sandwich = TRUE,
                        corstr = "independence",
                        scale.fix = TRUE,
                        init.phi = robust2.1.1glm$theta
                        )
```

```{r model2.1.1RobTable, results='show', echo=F, eval=F}
summary(robust2.1.1)
```


```{r model2.1.2Rob, results='hide', echo=F, eval=T}
robust2.1.2 <- lm_robust(lnLang ~ absLat + sdElev + sdSuitable + avgElev + avgSuitable +
                         avgPrecip + avgTemp +  lnArea + seaDist + waterArea + 
                         withinCountry +  numCountry +  migrationDist +  lnPopDens95,
                         data2 %>% filter((data2$suitableCells >= 10)),
                         fixed_effects = ~countryCode,
                         se_type = "stata")
```

```{r model2.1.2RobTable, results='show', echo=F, eval=F}
summary(robust2.1.2)
```

```{r model2.1.3Rob, results='hide', echo=F, eval=T}
robust2.1.3 <- lm_robust(lnLang ~ absLat + sdElev + sdSuitable + avgElev + avgSuitable +
                         avgPrecip + avgTemp +  lnArea + seaDist + waterArea +
                         withinCountry +  numCountry +  migrationDist +  lnPopDens95,
                         data2 %>% filter((data2$suitableCells >= 10) &
                                            (data2$totalPop95 >= 50000)),
                         fixed_effects = ~countryCode,
                         se_type = "stata")
```

```{r model2.1.3RobTable, results='show', echo=F, eval=F}
summary(robust2.1.3)
```

```{r tbl5a, results='hide', echo=F, eval=T}
models <- paste0("robust2.1.", 1:3)
coeffs <- c(list(setNames(robust2.1.1$beta, robust2.1.1$coefnames)[-1]),
            lapply(models[-1], function(model) { get(model)[["coefficients"]]})
            )
names(coeffs) <- models

vars <- unique(unlist(lapply(coeffs, names)))

coeffDf <- data.frame(row.names = vars)
for(model in models) coeffDf[names(coeffs[[model]]), model] <- coeffs[[model]]

ses <- c(list(sqrt(diag(robust2.1.1$var))[-1]),
         sapply(models[-1], function(model) get(model)["std.error"])
        )
names(ses) <- models
sesDf <- data.frame(row.names = vars)
for(model in models) sesDf[names(ses[[model]]), model] <- ses[[model]]

pvals <- c(list(setNames(summary(robust2.1.1)[[5]], robust2.1.1$coefnames)[-1]),
           sapply(models[-1], function(model) get(model)["p.value"])
        )
names(pvals) <- models
pvalsDf <- data.frame(row.names = vars)
for(model in models) pvalsDf[names(pvals[[model]]), model] <- pvals[[model]]

order <-c('sdElev', 'sdSuitable')

coeffDf <- coeffDf[order, ]
sesDf   <- sesDf[order, ]
pvalsDf <- pvalsDf[order, ]

# interleave rows
coeffDf[, "stat"] <- "Estimate"
sesDf[, "stat"] <- "SE"
tbl5a <- gdata::interleave(coeffDf, sesDf)
```

```{r tbl5aPrint, results='show', echo=F, eval=T}
# ensure a hard copy
tbl5aformat <- data.frame(tbl5a)

for (model in models) {
  estimRows <- !is.na(tbl5aformat[, model]) & (tbl5aformat$stat == 'Estimate')
  seRows <- !is.na(tbl5aformat[, model]) & (tbl5aformat$stat == 'SE')

  tbl5aformat[estimRows, model] <- sprintf(fmt = "%.3f", tbl5aformat[estimRows, model] %>%
                                             unlist() %>% as.numeric())
  tbl5aformat[seRows, model] <- paste0("(", sprintf(fmt = "%.3f", tbl5aformat[seRows, model]
                                             %>% unlist() 
                                             %>% as.numeric()), ")")
  
  significant <- rep(pvalsDf[, model] < .01, each = 2)
  significant[is.na(significant)] <- FALSE
  
  tbl5aformat[estimRows, model] <- cell_spec(tbl5aformat[estimRows, model],
                                             italic = significant[estimRows])
  tbl5aformat[seRows, model] <- cell_spec(tbl5aformat[seRows, model],
                                          italic = significant[seRows])
}

tbl5aformat$name <- c('Variation in elevation', NA, 'Variation in land quality', NA)

col.names <- c("Variable", "Negative binomial", "OLS1", "OLS2")

tbl5aformat %>% 
  select(name, 1:3, -stat) %>%
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE, linesep = c("", "\\addlinespace"),
             col.names = col.names, 
             row.names = F,
             align = "r", escape = F,
             caption = "Table 5A—Robustness Checks for the Virtual Country Analysis. Italics indicate significance at the 1\\% level.")  %>%
  row_spec(seq(2, nrow(tbl5aformat), 2), font_size = 8)

```

```{r tbl5aInfo, results='show', echo=F, eval=T}
tbl5ainfo <- data.frame(
  model = 1:3,
  cont = rep("Yes", 3),
  nobs = sapply(c("robust2.1.1glm", models[-1]), function(model) { nobs(get(model))}),
  rsq = c("-", lapply(models[-1], function(model) {
    formatC(
      summary(get(model))$r.squared
      , digits = 2, format = 'f')
    })) %>% unlist,
  loglik = c(formatC(robust2.1.1glm$twologlik / 2, digits = 2, format = 'f'), rep("-", 2)),
  row.names = NULL
  )

tbl5ainfo %>% 
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE,
               col.names = c('Model', 'Country Indicators', 'Observations', '$R^2$',
                             "Log pseudolikelihood"),
               escape = F,
               caption = "Information for each model in Table 5A: cross-country robustness check")
```





## Robustness Check 2

Table \ref{tab:tbl5bPrint} presents the results of the second series of robustness checks on the second model. All are 
ordinary least squares regressions with per-country fixed effects, while the errors reported are cluster-robust. 
As in section \ref{tab:tbl2bPrint}, the two most important covariates - the variations in elevation and land quality - are 
substituted first with their dispersions and the latter subsequently with its component parts.

The first regression is identical to regression 2.4 in the previous section in terms of covariates, but the data is filtered
so only the virtual countries which have complete coverage on all of their underlying 25 cells are included. 

The second regression adds an additional fixed effect for each percentile of the size distribution of the virtual countries:
we can stipulate this is to better capture the case if the dynamics are not stable across varying orders of magnitude in 
country size.

Regressions 3 - 5 follow section [Table 2B] in their choice of the substitutions for the two most important covariates:
dispersions instead of variations, and climatic and soil suitability instead of the overall composite metric.
All regressions include per-country fixed effects.

The results reasonably replicate those done on WLMS in terms of variable significance, except the variation in elevation
is found to be less significant in regressions 1 and 4. This might be attributed to the fact that, as mentioned, GREG contains
much fewer ethnic groups than WLMS does languages.

Table \ref{tab:tbl5bInfo} shows the $R^2$ coefficient for the regressions. The values are comparable to the best models
in the initial set of regressions. The best performing model in terms of this metric is the second one, which includes 
fixed-effects that take the country size into consideration. This implies that while it still holds that the two variations
are the biggest explanatory factors for ethnolinguistic diversity, the dynamics themselves are not completely invariant
to the size of the (virtual) country.



```{r model2.2.1Rob, results='hide', echo=F, eval=T}
robust2.2.1 <- lm_robust(lnLang ~ absLat + sdElev + sdSuitable + avgElev + avgSuitable +
                         avgPrecip + avgTemp +  lnArea + seaDist + waterArea +
                         withinCountry +  numCountry +  migrationDist +  lnPopDens95,
                         data2 %>% filter((data2$suitableCells == 25) &
                                          (data2$totalPop95 >= 3000)),
                         fixed_effects = ~countryCode,
                         se_type = "stata")
```

```{r model2.2.1RobTable, results='show', echo=F, eval=F}
summary(robust2.2.1)
```

```{r model2.2.2Rob, results='hide', echo=F, eval=T}
data222 <- data2 %>% filter((data2$suitableCells >= 10) & (data2$totalPop95 >= 3000))
sizePercentile <- quantile(data222$area, probs = seq(0, 1, length.out = 101))
data222[, "sizePerc"] <- factor(cut(data222$area, sizePercentile))

# NOTE: need to put the size percentile in manually, else doesn't work
robust2.2.2 <- lm_robust(lnLang ~ absLat + sdElev + sdSuitable + avgElev + avgSuitable +
                         avgPrecip + avgTemp + lnArea + seaDist + waterArea +
                         withinCountry +  numCountry +  migrationDist + 
                         lnPopDens95 + sizePerc,
                         data = data222,
                         # fixed_effects = ~ c(countryCode, sizePerc),
                         fixed_effects = ~ countryCode,
                         se_type = "stata")
```

```{r model2.2.2RobTable, results='show', echo=F, eval=F}
summary(robust2.2.2)
```

```{r model2.2.3Rob, results='hide', echo=F, eval=T}
robust2.2.3 <- lm_robust(lnLang ~ absLat + dispElev + dispSuitable + avgElev + avgSuitable +
                         avgPrecip + avgTemp +  lnArea + seaDist + waterArea +
                         withinCountry +  numCountry +  migrationDist +  lnPopDens95,
                         data2 %>% filter((data2$suitableCells >= 10) &
                                          (data2$totalPop95 >= 3000)),
                         fixed_effects = ~countryCode,
                         se_type = "stata")
```

```{r model2.2.3RobTable, results='show', echo=F, eval=F}
summary(robust2.2.3)
```

```{r model2.2.4Rob, results='hide', echo=F, eval=T}
robust2.2.4 <- lm_robust(lnLang ~ absLat + sdElev + sdClimate + avgElev + climate +  avgPrecip +
                         avgTemp +  lnArea + seaDist + waterArea +
                         withinCountry +  numCountry +  migrationDist +  lnPopDens95,
                         data2 %>% filter((data2$suitableCells >= 10) &
                                          (data2$totalPop95 >= 3000)),
                         fixed_effects = ~countryCode,
                         se_type = "stata")
```

```{r model2.2.4RobTable, results='show', echo=F, eval=F}
summary(robust2.2.4)
```

```{r model2.2.5Rob, results='hide', echo=F, eval=T}
robust2.2.5 <- lm_robust(lnLang ~ absLat + sdElev + sdSoil + avgElev + soil +  avgPrecip +
                         avgTemp +  lnArea + seaDist + waterArea +  withinCountry +
                         numCountry +  migrationDist +  lnPopDens95,
                         data2 %>% filter((data2$suitableCells >= 10) &
                                            (data2$totalPop95 >= 3000)),
                         fixed_effects = ~countryCode,
                         se_type = "stata")
```

```{r model2.2.5RobTable, results='show', echo=F, eval=F}
summary(robust2.2.5)
```

```{r tbl5b, results='hide', echo=F, eval=T}
models <- paste0("robust2.2.", 1:5)
coeffs <- c(lapply(models, function(model) { get(model)[["coefficients"]]}) )
names(coeffs) <- models

vars <- unique(unlist(lapply(coeffs, names)))

coeffDf <- data.frame(row.names = vars)
for(model in models) coeffDf[names(coeffs[[model]]), model] <- coeffs[[model]]

ses <- sapply(models, function(model) get(model)["std.error"])
names(ses) <- models
sesDf <- data.frame(row.names = vars)
for(model in models) sesDf[names(ses[[model]]), model] <- ses[[model]]

pvals <- sapply(models, function(model) get(model)["p.value"])
names(pvals) <- models
pvalsDf <- data.frame(row.names = vars)
for(model in models) pvalsDf[names(pvals[[model]]), model] <- pvals[[model]]

order <- c('sdElev', 'sdSuitable', 'dispElev', 'dispSuitable', 'sdClimate',
           'climate', 'sdSoil', 'soil')

coeffDf <- coeffDf[order, ]
sesDf   <- sesDf[order, ]
pvalsDf <- pvalsDf[order, ]

# interleave rows
coeffDf[, "stat"] <- "Estimate"
sesDf[, "stat"] <- "SE"
tbl5b <- gdata::interleave(coeffDf, sesDf)
```

```{r tbl5bPrint, results='show', echo=F, eval=T}
# ensure a hard copy
tbl5bformat <- data.frame(tbl5b)

for (model in models) {
  estimRows <- !is.na(tbl5bformat[, model]) & (tbl5bformat$stat == 'Estimate')
  seRows <- !is.na(tbl5bformat[, model]) & (tbl5bformat$stat == 'SE')

  tbl5bformat[estimRows, model] <- sprintf(fmt = "%.3f", tbl5bformat[estimRows, model] %>%
                                             unlist() %>% as.numeric())
  tbl5bformat[seRows, model] <- paste0("(", sprintf(fmt = "%.3f", tbl5bformat[seRows, model]
                                             %>% unlist() 
                                             %>% as.numeric()), ")")
  
  significant <- rep(pvalsDf[, model] < .01, each = 2)
  significant[is.na(significant)] <- FALSE
  
  tbl5bformat[estimRows, model] <- cell_spec(tbl5bformat[estimRows, model],
                                             italic = significant[estimRows])
  tbl5bformat[seRows, model] <- cell_spec(tbl5bformat[seRows, model],
                                          italic = significant[seRows])
}

tbl5bformat$name <- c('Variation in elevation', NA, 'Variation in land quality', NA,
                      'Dispersion of elevation', NA, 'Dispersion of land quality', NA,
                      'Variation in climatic suitability', NA, 'Mean climatic suitability', NA,
                      'Variation in soil suitability', NA, 'Mean soil suitability', NA)

col.names <- c("Variable", paste0("(", 1:5, ")"))

tbl5bformat %>% 
  select(name, 1:5, -stat) %>%
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE, linesep = c("", "\\addlinespace"),
             col.names = col.names, 
             row.names = F,
             align = "r", escape = F,
             caption = "Table 5B—Robustness Checks for the Virtual Country Analysis. Italics indicate significance at the 1\\% level.")  %>%
  row_spec(seq(2, nrow(tbl5bformat), 2), font_size = 8)

```

```{r tbl5bInfo, results='show', echo=F, eval=T}
tbl5binfo <- data.frame(
  model = 1:5,
  cont = rep("Yes", 5),
  nobs = sapply(models, function(model) { nobs(get(model))}),
  rsq = lapply(models, function(model) {
    formatC(
      summary(get(model))$r.squared
      , digits = 2, format = 'f')
    }) %>% unlist,
  row.names = NULL
  )

tbl5binfo %>% 
  knitr::kable(toprule = '', bottomrule = '', booktabs = TRUE,
               col.names = c('Model', 'Country Indicators', 'Observations', '$R^2$'),
               escape = F,
               caption = "Information for each model in Table 5B: cross-country robustness check")
```



# Conclusion

Our replication seems to give credence to the hypothesis put forth in the original paper:  

> The empirical analysis conducted ... establishes that geographic variability, captured by variation in regional land quality
and elevation, is a fundamental determinant of contemporary linguistic diversity. The findings are consistent with the proposed hypothesis
that differences in land endowments gave rise to location-specific human capital, leading to the formation of localized ethnicities.

A representative example of the formation of separate ethnicities being induced by a high variance in the land quality and elevation
is that of the latter two allowing for two separate populations in a relatively small geographic area to practice drastically
different modes of subsistence. The (usually) low-lying, higher quality land is conductive to intensive farming, while 
the adjacent lower quality, hillier terrain permits only pastoralism. With time, these two populations develop separate customs and languages,
leading to a separate sense of ethnic belonging.



# References

<div id="refs"></div>


\newpage
# Appendix: code
<!-- NOTE: add code chunks to be displayed here -->
```{r codeAppendix, ref.label=c('dataImport1', 'rename1', 'greeceNepal', 'worldMap', 'summary', 'standardize1', 'model1.1', 'model1.2', 'model1.3', 'model1.4', 'model1.5', 'tbl1', 'tbl1Print', 'tbl1Info', 'resid1', 'model1.1Rob', 'model1.2Rob', 'model1.3Rob',  'model1.4Rob', 'tbl2a', 'tbl2aPrint', 'tbl2aInfo', 'data_import2b', 'model1.2.1', 'model1.2.2', 'model1.2.3', 'model1.2.4', 'model1.2.5', 'model1.2.6', 'model1.2.7', 'tbl2b', 'tbl2bPrint', 'tbl2bInfo', 'dataImport2', 'rename2', 'model2.1', 'model2.2', 'model2.3', 'model2.4', 'model2.5', 'model2.6', 'model2.7', 'tbl4', 'tbl4Print', 'tbl4Info', 'model2.1.1Rob', 'model2.1.2Rob', 'model2.1.3Rob', 'tbl5a', 'tbl5aPrint', 'tbl5aInfo', 'model2.2.1Rob', 'model2.2.2Rob', 'model2.2.3Rob', 'model2.2.4Rob', 'model2.2.5Rob', 'tbl5b', 'tbl5bPrint', 'tbl5bInfo'), echo=T, eval=F}

```








